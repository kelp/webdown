{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Webdown","text":"<p>A Python CLI tool for converting web pages to clean, readable Markdown format. Webdown makes it easy to download documentation and feed it into an LLM coding tool.</p>"},{"location":"#why-webdown","title":"Why Webdown?","text":"<ul> <li>Clean Conversion: Produces readable Markdown without formatting artifacts</li> <li>Multi-Page Crawling: Crawl entire documentation sites with <code>webdown crawl</code></li> <li>Selective Extraction: Target specific page sections with CSS selectors</li> <li>Claude XML Format: Optimized output format for Anthropic's Claude AI models</li> <li>Progress Tracking: Visual download progress for large pages with <code>-p</code> flag</li> <li>Optimized Handling: Automatic streaming for large pages (&gt;10MB) with no   configuration required</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#documentation-for-ai-coding-assistants","title":"Documentation for AI Coding Assistants","text":"<p>Webdown is particularly useful for preparing documentation to use with AI-assisted coding tools like Claude Code, GitHub Copilot, or ChatGPT:</p> <ul> <li>Convert technical documentation into clean Markdown for AI context</li> <li>Extract only the relevant parts of large documentation pages using CSS selectors</li> <li>Strip out images and formatting that might consume token context</li> <li>Generate well-structured tables of contents for better navigation</li> </ul> <pre><code># Example: Convert API docs and store for AI coding context\nwebdown https://api.example.com/docs -s \"main\" -I -c -w 80 -o api_context.md\n</code></pre>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-pypi","title":"From PyPI","text":"<pre><code>pip install webdown\n</code></pre>"},{"location":"#with-homebrew","title":"With Homebrew","text":"<pre><code># Add the tap\nbrew tap kelp/tools\n\n# Install webdown\nbrew install webdown\n</code></pre>"},{"location":"#install-from-source","title":"Install from Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/kelp/webdown.git\ncd webdown\n\n# Install with pip\npip install .\n\n# Or install with Poetry\npoetry install\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Basic usage:</p> <pre><code>webdown https://example.com/page.html -o output.md\n</code></pre> <p>Output to stdout:</p> <pre><code>webdown https://example.com/page.html\n</code></pre>"},{"location":"#options","title":"Options","text":"<ul> <li><code>-o, --output</code>: Output file (default: stdout)</li> <li><code>-t, --toc</code>: Generate table of contents</li> <li><code>-L, --no-links</code>: Strip hyperlinks</li> <li><code>-I, --no-images</code>: Exclude images</li> <li><code>-s, --css SELECTOR</code>: CSS selector to extract specific content</li> <li><code>-c, --compact</code>: Remove excessive blank lines from the output</li> <li><code>-w, --width N</code>: Set the line width for wrapped text (0 for no wrapping)</li> <li><code>-p, --progress</code>: Show download progress bar (useful for large files)</li> <li><code>--claude-xml</code>: Output in Claude XML format for use with Claude AI</li> <li><code>--no-metadata</code>: Exclude metadata section from Claude XML output (metadata is included by default)</li> <li><code>--no-date</code>: Exclude current date from metadata in Claude XML output (date is included by default)</li> </ul> <p>For more details on the Claude XML format, see the Anthropic documentation on Claude XML.</p> <p>For large web pages (over 10MB), streaming mode is automatically used to optimize memory usage without any configuration required.</p>"},{"location":"#examples","title":"Examples","text":"<p>Generate markdown with a table of contents:</p> <pre><code>webdown https://example.com -t -o output.md\n</code></pre> <p>Extract only main content:</p> <pre><code>webdown https://example.com -s \"main\" -o output.md\n</code></pre> <p>Strip links and images:</p> <pre><code>webdown https://example.com -L -I -o output.md\n</code></pre> <p>Compact output with progress bar and line wrapping:</p> <pre><code>webdown https://example.com -c -p -w 80 -o output.md\n</code></pre> <p>Generate Claude XML format for use with Claude AI:</p> <pre><code>webdown https://example.com --claude-xml -o doc.xml\n</code></pre> <p>Claude XML with no metadata section:</p> <pre><code>webdown https://example.com --claude-xml --no-metadata -o doc.xml\n</code></pre> <p>Claude XML without the current date in metadata:</p> <pre><code>webdown https://example.com --claude-xml --no-date -o doc.xml\n</code></pre>"},{"location":"#crawling-multiple-pages","title":"Crawling Multiple Pages","text":"<p>Crawl an entire documentation site:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre> <p>Crawl with depth and delay settings:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/ --max-depth 5 --delay 2.0\n</code></pre> <p>Crawl from a sitemap:</p> <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre> <p>Crawl with content options:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/ -s \"main\" --claude-xml\n</code></pre>"},{"location":"#crawl-options","title":"Crawl Options","text":"<ul> <li><code>--max-depth N</code>: Maximum crawl depth from seed URLs (default: 3)</li> <li><code>--delay SECONDS</code>: Delay between requests (default: 1.0)</li> <li><code>--same-domain</code>: Allow crawling any path on the same domain</li> <li><code>--path-prefix PREFIX</code>: Only crawl URLs starting with this prefix</li> <li><code>--sitemap URL</code>: Parse sitemap.xml instead of crawling links</li> <li><code>--max-pages N</code>: Maximum number of pages to crawl (0 for unlimited)</li> <li><code>-q, --quiet</code>: Suppress progress output</li> </ul> <p>For complete documentation, use the <code>--help</code> flag:</p> <pre><code>webdown --help\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>API documentation is available online at tcole.net/webdown.</p> <p>You can also generate the documentation locally with:</p> <pre><code>make docs        # Generate HTML docs in the docs/ directory\nmake docs-serve  # Start a local documentation server at http://localhost:8080\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+ (3.13 recommended)</li> <li>Poetry for dependency management</li> </ul>"},{"location":"#setup","title":"Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/kelp/webdown.git\ncd webdown\n\n# Install dependencies with Poetry\npoetry install\npoetry run pre-commit install\n\n# Optional: Start a Poetry shell for interactive development\npoetry shell\n</code></pre>"},{"location":"#development-commands","title":"Development Commands","text":"<p>We use a Makefile to streamline development tasks:</p> <pre><code># Install dependencies\nmake install\n\n# Run tests\nmake test\n\n# Run tests with coverage\nmake test-coverage\n\n# Run integration tests\nmake integration-test\n\n# Run linting\nmake lint\n\n# Run type checking\nmake type-check\n\n# Format code\nmake format\n\n# Run all pre-commit hooks\nmake pre-commit\n\n# Run all checks (lint, type-check, test)\nmake all-checks\n\n# Build package\nmake build\n\n# Start interactive Poetry shell\nmake shell\n\n# Generate documentation\nmake docs\n\n# Start documentation server\nmake docs-serve\n\n# Publishing to PyPI (maintainers only)\n# See CONTRIBUTING.md for details on the release process\nmake build         # Build package\nmake publish-test  # Publish to TestPyPI (for testing)\n\n# Show all available commands\nmake help\n</code></pre>"},{"location":"#poetry-commands","title":"Poetry Commands","text":"<p>You can also use Poetry directly:</p> <pre><code># Start an interactive shell in the Poetry environment\npoetry shell\n\n# Run a command in the Poetry environment\npoetry run pytest\n\n# Add a new dependency\npoetry add requests\n\n# Add a development dependency\npoetry add --group dev black\n\n# Update dependencies\npoetry update\n\n# Build package\npoetry build\n</code></pre>"},{"location":"#python-api-usage","title":"Python API Usage","text":"<p>Webdown can also be used as a Python library in your own projects:</p> <pre><code>from webdown.converter import convert_url_to_markdown, WebdownConfig\n\n# Basic conversion\nmarkdown = convert_url_to_markdown(\"https://example.com\")\n\n# Using the Config object for more options\nconfig = WebdownConfig(\n    url=\"https://example.com\",\n    include_toc=True,\n    css_selector=\"main\",\n    compact_output=True,\n    body_width=80,\n    show_progress=True\n)\nmarkdown = convert_url_to_markdown(config)\n\n# Save to file\nwith open(\"output.md\", \"w\") as f:\n    f.write(markdown)\n\n# Convert to Claude XML format (optimized for Anthropic's Claude AI)\nfrom webdown.converter import convert_url_to_claude_xml, ClaudeXMLConfig\n\n# Basic Claude XML conversion\nxml = convert_url_to_claude_xml(\"https://example.com\")\n\n# With custom XML configuration\nclaude_config = ClaudeXMLConfig(\n    include_metadata=True,   # Include title, URL, and date (default: True)\n    add_date=True,           # Include current date in metadata (default: True)\n    doc_tag=\"claude_documentation\"  # Root document tag name (default)\n)\nxml = convert_url_to_claude_xml(\"https://example.com\", claude_config)\n\n# Save XML output\nwith open(\"output.xml\", \"w\") as f:\n    f.write(xml)\n\n# For more information on Claude XML format, see:\n# https://docs.anthropic.com/claude/docs/advanced-data-extraction\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p> <ol> <li>Fork the repository</li> <li>Create your feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Run tests to make sure everything works:    <pre><code># Run standard tests\npoetry run pytest\n\n# Run tests with coverage\npoetry run pytest --cov=webdown\n\n# Run integration tests\npoetry run pytest --integration\n</code></pre></li> <li>Commit your changes (<code>git commit -m 'Add some amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol> <p>Please make sure your code passes all tests, type checks, and follows our coding style (enforced by pre-commit hooks). We aim to maintain high code coverage (currently at 93%). When adding features, please include tests.</p> <p>For more details, see our Contributing Guide.</p>"},{"location":"#support","title":"Support","text":"<p>If you encounter any problems or have feature requests, please open an issue on GitHub.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - see the LICENSE file for details.</p> <p>Documentation Links</p> <p>For full documentation, check out these additional resources: - CLI Reference - Comprehensive command-line interface documentation - CLI Cheat Sheet - Quick reference for common commands - API Reference - Detailed documentation for Python API - Changelog - Version history and changes - Contributing Guide - How to contribute to the project - License - MIT License details</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#080-2025-12-10","title":"[0.8.0] - 2025-12-10","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Crawler feature: New <code>webdown crawl</code> subcommand for converting multiple   pages from a website</li> <li>Breadth-first crawling with configurable depth and rate limiting</li> <li>Sitemap.xml parsing support with <code>--sitemap</code> option</li> <li>Scope control: <code>--same-domain</code>, <code>--same-subdomain</code>, <code>--path-prefix</code></li> <li>Output manifest (index.json) with crawl metadata</li> <li>New Python API: <code>crawl()</code>, <code>crawl_from_sitemap()</code>, <code>CrawlerConfig</code>,   <code>ScopeType</code>, <code>CrawlResult</code>, <code>CrawledPage</code></li> <li>New modules: <code>crawler.py</code>, <code>link_extractor.py</code>, <code>output_manager.py</code></li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>CLI now supports subcommands (existing behavior unchanged for backward   compatibility)</li> <li>Updated all dependencies to latest versions</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Added crawler API documentation to mkdocs (crawler, link_extractor,   output_manager modules)</li> <li>Added crawling examples to API overview page</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Fixed regex package vulnerability (CVE in version 2024.11.6)</li> <li>Updated cryptography 44.0.2 \u2192 46.0.3</li> <li>Updated urllib3 2.5.0 \u2192 2.6.1</li> </ul>"},{"location":"changelog/#071-2025-12-10","title":"[0.7.1] - 2025-12-10","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated all dependencies to latest versions</li> </ul>"},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Fixed regex package vulnerability (CVE in version 2024.11.6)</li> <li>Updated cryptography 44.0.2 \u2192 46.0.3</li> <li>Updated urllib3 2.5.0 \u2192 2.6.1</li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>pydantic 2.9.2 \u2192 2.12.5</li> <li>black 25.9.0 \u2192 25.12.0</li> <li>mypy 1.18.2 \u2192 1.19.0</li> <li>mkdocs-material 9.6.21 \u2192 9.7.0</li> <li>coverage 7.8.0 \u2192 7.13.0</li> <li>pre-commit 4.3.0 \u2192 4.5.0</li> <li>beautifulsoup4 4.14.2 \u2192 4.14.3</li> <li>regex 2024.11.6 \u2192 2025.11.3</li> <li>actions/checkout 4 \u2192 6</li> <li>actions/upload-artifact 4 \u2192 5</li> </ul>"},{"location":"changelog/#070-2025-04-05","title":"[0.7.0] - 2025-04-05","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>CLI interface now requires explicit <code>-u/--url</code> or <code>-f/--file</code> flags for source input</li> <li>URL must now be specified with <code>-u/--url</code> flag instead of as a positional argument</li> <li>All CLI examples in documentation have been updated to reflect the new syntax</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for converting local HTML files to Markdown with <code>-f/--file</code> option</li> <li>New <code>convert_file</code> function in the Python API for local HTML file conversion</li> <li>New <code>read_html_file</code> function for reading HTML from the local filesystem</li> <li>Added error codes for file-related errors (FILE_NOT_FOUND, PERMISSION_DENIED, IO_ERROR)</li> <li>Comprehensive documentation with examples for local file conversion</li> <li>Comprehensive CLI test script (<code>scripts/test_cli.sh</code>) for testing all CLI options with real websites</li> </ul>"},{"location":"changelog/#063-2025-03-22","title":"[0.6.3] - 2025-03-22","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Updated project status from Alpha to Beta to reflect stability and completeness</li> <li>Enhanced PyPI metadata with improved descriptions and keywords</li> <li>Added additional classifiers for better project categorization</li> <li>Added project URLs for documentation, bug tracker, source code, and changelog</li> </ul>"},{"location":"changelog/#062-2025-03-22","title":"[0.6.2] - 2025-03-22","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Added poetry.lock to version control for reproducible builds</li> <li>Updated all dependencies to their latest compatible versions</li> <li>Pin safety package to version 3.3.1</li> <li>Enhanced GitHub Actions workflows with better cache handling to avoid conflicts</li> </ul>"},{"location":"changelog/#security_2","title":"Security","text":"<ul> <li>Updated safety scanner from 2.3.5 to 3.3.1 for improved vulnerability detection</li> </ul>"},{"location":"changelog/#061-2025-03-22","title":"[0.6.1] - 2025-03-22","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Code style and formatting issues in test files</li> <li>GitHub Actions cache conflict warnings by improving cache key uniqueness</li> <li>Added Python version to GitHub Actions cache keys for better matrix build separation</li> </ul>"},{"location":"changelog/#060-2025-03-22","title":"[0.6.0] - 2025-03-22","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Comprehensive documentation for troubleshooting and error handling</li> <li>Advanced Table of Contents (TOC) documentation with examples and customization guidance</li> <li>Documentation for streaming large files, explaining the 10MB threshold implementation</li> <li>Improved API documentation with correct module references after refactoring</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Major refactoring to improve code organization and maintainability:</li> <li>Split monolithic converter.py into logical modules (html_parser.py, markdown_converter.py, xml_converter.py)</li> <li>Replaced complex placeholder system for code blocks with direct processing</li> <li>Reduced XML helper functions from 7+ to 3-4 clear functions</li> <li>Created reusable validation and error handling utilities</li> <li>Consolidated configuration into dedicated classes (WebdownConfig, DocumentOptions)</li> <li>Eliminated duplicate code in XML converter with new <code>_process_paragraphs()</code> helper function</li> <li>Improved test coverage to 100% across all application code</li> <li>Simplified streaming implementation with fixed 10MB threshold</li> <li>Updated configuration class documentation to reflect actual implementation</li> <li>Reorganized codebase following clean architecture principles</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Documentation build after modular architecture refactoring</li> <li>Corrected API references in documentation</li> <li>Validation issues in error handling code</li> <li>Improved error reporting for various failure scenarios</li> </ul>"},{"location":"changelog/#050-2025-03-21","title":"[0.5.0] - 2025-03-21","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Claude XML format support with <code>--claude-xml</code> flag</li> <li>Optimized XML structure for use with Anthropic's Claude AI models</li> <li>Metadata handling in Claude XML output with <code>--no-metadata</code> and <code>--no-date</code> options</li> <li>New test suite for Claude XML functionality</li> <li>Documentation for Claude XML format</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Simplified streaming implementation with fixed 10MB threshold</li> <li>Removed <code>stream_threshold</code> parameter from WebdownConfig</li> <li>Removed advanced HTML2Text options to simplify the API</li> <li>Improved README documentation for clarity and simplicity</li> <li>Added code quality improvement tasks to TODO.md</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Improved streaming mode detection reliability</li> <li>Better error handling in the streaming implementation</li> </ul>"},{"location":"changelog/#042-2025-03-16","title":"[0.4.2] - 2025-03-16","text":""},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>Migrated documentation to MkDocs with Material theme for better API reference</li> <li>Added proper documentation site with auto-generation from docstrings</li> <li>Fixed documentation deployment to GitHub Pages</li> <li>Improved docstrings to be more consistent across modules</li> </ul>"},{"location":"changelog/#041-2025-03-15","title":"[0.4.1] - 2025-03-15","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added pdoc documentation generation with <code>make docs</code> and <code>make docs-serve</code> commands</li> <li>Generated documentation now available in the <code>docs/</code> directory</li> </ul>"},{"location":"changelog/#improved_1","title":"Improved","text":"<ul> <li>Enhanced CLI documentation with detailed explanations and practical examples</li> <li>Improved command-line help with logically organized option groups and better descriptions</li> <li>Added epilog with link to project repository</li> </ul>"},{"location":"changelog/#040-2025-03-15","title":"[0.4.0] - 2025-03-15","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Introduced WebdownConfig class for better parameter organization and configuration</li> <li>Added comprehensive support for advanced HTML2Text options in both CLI and API:</li> <li>Single line break mode (<code>--single-line-break</code>)</li> <li>Unicode character support (<code>--unicode</code>)</li> <li>HTML tables preservation (<code>--tables-as-html</code>)</li> <li>Custom emphasis and strong emphasis markers (<code>--emphasis-mark</code>, <code>--strong-mark</code>)</li> <li>Link protection, image handling options, and more in the API</li> <li>Improved CLI with advanced options group for better help display</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Simplified the exception hierarchy to a single WebdownError class</li> <li>Updated API to support both parameter-based and config-based approaches</li> <li>Improved documentation with detailed examples for new features</li> <li>Updated all dependencies to latest versions</li> <li>html2text updated from 2020.1.16 to 2024.2.26</li> <li>beautifulsoup4, requests, tqdm and all dev dependencies updated to latest versions</li> </ul>"},{"location":"changelog/#031-2025-03-15","title":"[0.3.1] - 2025-03-15","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Updated all dependencies to latest versions</li> <li>html2text updated from 2020.1.16 to 2024.2.26</li> <li>beautifulsoup4, requests, tqdm and all dev dependencies updated to latest versions</li> </ul>"},{"location":"changelog/#030-2025-03-15","title":"[0.3.0] - 2025-03-15","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Command-line option <code>-w/--width</code> to set html2text body_width for text wrapping</li> <li>Progress bar for downloads with new <code>-p/--progress</code> flag</li> <li>Support for CSS selectors with <code>-s/--css</code> to extract specific page sections</li> <li>Compact output option with <code>-c/--compact</code> to remove excessive blank lines</li> <li>Automatic removal of zero-width spaces and other invisible characters</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Migrated to modern Python packaging using Poetry</li> <li>Updated Python requirements to 3.10+</li> <li>Changed CSS selector flag from <code>-c</code> to <code>-s</code> to avoid conflict with compact flag</li> <li>Improved documentation with comprehensive docstrings</li> <li>Enhanced test coverage to 100% (excluding integration tests)</li> </ul>"},{"location":"changelog/#020-2025-03-12","title":"[0.2.0] - 2025-03-12","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Initial release with basic web to markdown conversion</li> <li>Support for table of contents generation</li> <li>Link and image handling options</li> </ul>"},{"location":"claude-xml-format/","title":"Claude XML Format Support","text":"<p>Webdown includes support for generating Claude XML, a structured format optimized for use with Anthropic's Claude AI models. This format helps Claude better understand and process the content.</p>"},{"location":"claude-xml-format/#benefits-of-claude-xml","title":"Benefits of Claude XML","text":"<ul> <li>Better content organization: Helps Claude understand the structure of your content</li> <li>Improved code handling: Code blocks are properly tagged with language information</li> <li>Metadata support: Includes title, source URL, and date information</li> </ul>"},{"location":"claude-xml-format/#using-claude-xml-format","title":"Using Claude XML Format","text":"<p>To generate Claude XML output, use the <code>--claude-xml</code> flag:</p> <pre><code>webdown https://example.com --claude-xml -o output.xml\n</code></pre>"},{"location":"claude-xml-format/#available-options","title":"Available Options","text":"<ul> <li><code>--claude-xml</code>: Output in Claude XML format instead of Markdown</li> <li><code>--metadata</code>: Include metadata section in XML (default: True)</li> <li><code>--no-metadata</code>: Exclude metadata section from XML</li> </ul>"},{"location":"claude-xml-format/#xml-structure","title":"XML Structure","text":"<p>The Claude XML format used by webdown follows this structure:</p> <pre><code>&lt;claude_documentation&gt;\n  &lt;metadata&gt;\n    &lt;title&gt;Documentation Title&lt;/title&gt;\n    &lt;source&gt;https://source-url.com&lt;/source&gt;\n    &lt;date&gt;2025-03-20&lt;/date&gt;\n  &lt;/metadata&gt;\n\n  &lt;content&gt;\n    &lt;section&gt;\n      &lt;heading&gt;Section Heading&lt;/heading&gt;\n      &lt;text&gt;Regular paragraph text goes here...&lt;/text&gt;\n\n      &lt;code language=\"python\"&gt;\ndef example_function():\n    return \"This is a code example\"\n      &lt;/code&gt;\n    &lt;/section&gt;\n  &lt;/content&gt;\n&lt;/claude_documentation&gt;\n</code></pre>"},{"location":"claude-xml-format/#example-usage","title":"Example Usage","text":"<pre><code># Basic Claude XML conversion\nwebdown https://example.com --claude-xml -o output.xml\n\n# Extract specific content with no metadata\nwebdown https://example.com -s \"main\" --claude-xml --no-metadata -o api_docs.xml\n\n# Compact output with no images\nwebdown https://example.com -I -c --claude-xml -o content.xml\n</code></pre>"},{"location":"claude-xml-format/#python-api-usage","title":"Python API Usage","text":"<pre><code>from webdown.converter import convert_url_to_claude_xml\n\n# Basic usage\nxml = convert_url_to_claude_xml(\"https://example.com\")\n\n# Save to file\nwith open(\"output.xml\", \"w\") as f:\n    f.write(xml)\n</code></pre>"},{"location":"cli-cheatsheet/","title":"CLI Cheat Sheet","text":"<p>Quick reference guide for the Webdown command-line interface.</p>"},{"location":"cli-cheatsheet/#basic-commands","title":"Basic Commands","text":"<pre><code># Basic conversion\nwebdown https://example.com\n\n# Save to file\nwebdown https://example.com -o output.md\n\n# Generate table of contents\nwebdown https://example.com -t\n\n# Show progress bar\nwebdown https://example.com -p\n\n# Extract specific content\nwebdown https://example.com -s \"main\"\n\n# Plain text version (no links/images)\nwebdown https://example.com -L -I\n\n# Compact output with width of 80 chars\nwebdown https://example.com -c -w 80\n</code></pre>"},{"location":"cli-cheatsheet/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Single line breaks (more compact)\nwebdown https://example.com --single-line-break\n\n# Unicode support\nwebdown https://example.com --unicode\n\n# Custom emphasis markers\nwebdown https://example.com --emphasis-mark \"*\" --strong-mark \"__\"\n\n# Keep tables as HTML\nwebdown https://example.com --tables-as-html\n\n# Streaming mode for large documents (5MB threshold)\nwebdown https://example.com --stream-threshold 5242880\n\n# Protect links from wrapping\nwebdown https://example.com --protect-links\n\n# Images as HTML\nwebdown https://example.com --images-as-html\n\n# Default alt text for images\nwebdown https://example.com --default-image-alt \"image\"\n\n# Add padding to tables\nwebdown https://example.com --pad-tables\n\n# Wrap list items\nwebdown https://example.com --wrap-list-items\n</code></pre>"},{"location":"cli-cheatsheet/#complete-example","title":"Complete Example","text":"<pre><code># Extract main content, add TOC, compact output, 80 char width,\n# show progress, use Unicode, and single line breaks\nwebdown https://example.com -s \"main\" -t -c -w 80 -p \\\n  --unicode --single-line-break -o output.md\n</code></pre>"},{"location":"cli-cheatsheet/#options-reference","title":"Options Reference","text":"Category Option Description Output <code>-o FILE</code> Write to file <code>-p</code> Show progress bar Content <code>-s SELECTOR</code> CSS selector for content <code>-L</code> Remove links <code>-I</code> Remove images Format <code>-t</code> Add table of contents <code>-c</code> Compact output <code>-w N</code> Set line width <code>--stream-threshold N</code> Size threshold for streaming Advanced <code>--single-line-break</code> Use single line breaks <code>--unicode</code> Use Unicode characters <code>--protect-links</code> Prevent link wrapping <code>--images-as-html</code> Keep images as HTML <code>--tables-as-html</code> Keep tables as HTML <code>--emphasis-mark CHAR</code> Custom emphasis marker <code>--strong-mark CHARS</code> Custom strong emphasis marker <code>--default-image-alt TEXT</code> Default alt text <code>--pad-tables</code> Add padding for tables <code>--wrap-list-items</code> Wrap list items Meta <code>-V</code> Show version <code>-h</code> Show help"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Webdown offers a straightforward command-line interface for converting web pages to Markdown or Claude XML format.</p>"},{"location":"cli-reference/#basic-usage","title":"Basic Usage","text":""},{"location":"cli-reference/#single-page-conversion","title":"Single Page Conversion","text":"<pre><code>webdown -u URL [options]\nwebdown -f FILE [options]\n</code></pre> <p>Convert a single web page or local HTML file to Markdown.</p>"},{"location":"cli-reference/#multi-page-crawling","title":"Multi-Page Crawling","text":"<pre><code>webdown crawl URL [options]\n</code></pre> <p>Crawl multiple pages from a website and convert them all.</p>"},{"location":"cli-reference/#complete-options-reference","title":"Complete Options Reference","text":""},{"location":"cli-reference/#inputoutput-options","title":"Input/Output Options","text":"Option Description <code>-o FILE, --output FILE</code> Write Markdown output to FILE instead of stdout <code>-p, --progress</code> Display a progress bar during download (useful for large pages)"},{"location":"cli-reference/#content-selection","title":"Content Selection","text":"Option Description <code>-s SELECTOR, --css SELECTOR</code> Extract content matching CSS selector (e.g., 'main', '.content') <code>-L, --no-links</code> Convert hyperlinks to plain text (remove all link markup) <code>-I, --no-images</code> Exclude images from the output completely"},{"location":"cli-reference/#formatting-options","title":"Formatting Options","text":"Option Description <code>-t, --toc</code> Generate a table of contents based on headings in the document <code>-c, --compact</code> Remove excessive blank lines for more compact output <code>-w N, --width N</code> Set line width (0 disables wrapping, 80 recommended for readability)"},{"location":"cli-reference/#claude-xml-options","title":"Claude XML Options","text":"Option Description <code>--claude-xml</code> Output in Claude XML format instead of Markdown <code>--metadata</code> Include metadata section in XML (default) <code>--no-metadata</code> Exclude metadata section from XML"},{"location":"cli-reference/#meta-options","title":"Meta Options","text":"Option Description <code>-V, --version</code> Show version information and exit <code>-h, --help</code> Show help message and exit"},{"location":"cli-reference/#examples-with-explanations","title":"Examples with Explanations","text":""},{"location":"cli-reference/#basic-conversion","title":"Basic Conversion","text":"<p><pre><code>webdown https://example.com\n</code></pre> Converts the web page at example.com to Markdown and outputs to the terminal.</p>"},{"location":"cli-reference/#save-to-file","title":"Save to File","text":"<p><pre><code>webdown https://example.com -o example.md\n</code></pre> Converts the web page and saves the output to example.md.</p>"},{"location":"cli-reference/#generate-table-of-contents","title":"Generate Table of Contents","text":"<p><pre><code>webdown https://example.com -t\n</code></pre> Adds a table of contents based on the headings found in the document.</p>"},{"location":"cli-reference/#extract-main-content","title":"Extract Main Content","text":"<p><pre><code>webdown https://example.com -s \"main\"\n</code></pre> Extracts only the content inside the <code>&lt;main&gt;</code> tag, ignoring headers, footers, sidebars, etc.</p>"},{"location":"cli-reference/#plain-text-no-links-or-images","title":"Plain Text (No Links or Images)","text":"<p><pre><code>webdown https://example.com -L -I\n</code></pre> Creates a plain text version by removing hyperlinks and images.</p>"},{"location":"cli-reference/#compact-output-with-custom-width","title":"Compact Output with Custom Width","text":"<p><pre><code>webdown https://example.com -c -w 80\n</code></pre> Removes excessive blank lines and wraps text at 80 characters.</p>"},{"location":"cli-reference/#show-progress-for-large-pages","title":"Show Progress for Large Pages","text":"<p><pre><code>webdown https://example.com -p\n</code></pre> Displays a progress bar during download, useful for large pages.</p>"},{"location":"cli-reference/#claude-xml-format","title":"Claude XML Format","text":"<p><pre><code>webdown https://example.com --claude-xml -o output.xml\n</code></pre> Outputs the page content in Claude XML format, optimized for use with Anthropic's Claude AI.</p>"},{"location":"cli-reference/#complete-example-with-multiple-options","title":"Complete Example with Multiple Options","text":"<p><pre><code>webdown https://example.com -s \"main\" -t -c -w 80 -p -o example.md\n</code></pre> This example: - Extracts content from the <code>&lt;main&gt;</code> tag - Generates a table of contents - Removes excessive blank lines - Wraps text at 80 characters - Shows a progress bar during download - Saves output to example.md</p>"},{"location":"cli-reference/#cli-cheat-sheet","title":"CLI Cheat Sheet","text":"Task Command Basic conversion <code>webdown -u https://example.com</code> Save to file <code>webdown -u https://example.com -o file.md</code> Add table of contents <code>webdown -u https://example.com -t</code> Extract main content <code>webdown -u https://example.com -s \"main\"</code> Plain text version <code>webdown -u https://example.com -L -I</code> Compact output <code>webdown -u https://example.com -c</code> Set text width <code>webdown -u https://example.com -w 80</code> Show progress <code>webdown -u https://example.com -p</code> Claude XML format <code>webdown -u https://example.com --claude-xml</code> Crawl site <code>webdown crawl https://docs.example.com/ -o ./output/</code> Crawl from sitemap <code>webdown crawl --sitemap https://example.com/sitemap.xml -o ./output/</code>"},{"location":"cli-reference/#crawl-command-reference","title":"Crawl Command Reference","text":"<p>The <code>crawl</code> subcommand converts multiple pages from a website.</p>"},{"location":"cli-reference/#crawl-options","title":"Crawl Options","text":"Option Description <code>-o DIR, --output DIR</code> Output directory for converted files (required) <code>--sitemap URL</code> Parse sitemap.xml instead of crawling links <code>--max-depth N</code> Maximum crawl depth from seed URLs (default: 3) <code>--delay SECONDS</code> Delay between requests in seconds (default: 1.0) <code>--same-domain</code> Allow crawling any path on the same domain <code>--path-prefix PREFIX</code> Only crawl URLs starting with this path prefix <code>--max-pages N</code> Maximum number of pages to crawl (0 for unlimited) <code>-q, --quiet</code> Suppress progress output <p>All content selection and formatting options (<code>-s</code>, <code>-L</code>, <code>-I</code>, <code>-t</code>, <code>-c</code>, <code>-w</code>, <code>--claude-xml</code>) also work with the crawl command.</p>"},{"location":"cli-reference/#crawl-examples","title":"Crawl Examples","text":"<p>Crawl a documentation site:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre> <p>Crawl with depth and delay settings:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/ --max-depth 5 --delay 2.0\n</code></pre> <p>Crawl from a sitemap:</p> <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre> <p>Crawl with content extraction and Claude XML output:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/ -s \"main\" --claude-xml\n</code></pre> <p>Crawl only a specific path prefix:</p> <pre><code>webdown crawl https://docs.example.com/api/ -o ./output/ --path-prefix /api/\n</code></pre>"},{"location":"contributing/","title":"Contributing Guide","text":""},{"location":"contributing/#contributing-to-webdown","title":"Contributing to Webdown","text":"<p>Thank you for your interest in contributing to Webdown! This document provides guidelines and instructions for contributing to this project.</p>"},{"location":"contributing/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Poetry for dependency management</li> <li>Git</li> </ul>"},{"location":"contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/kelp/webdown.git\ncd webdown\n</code></pre></p> </li> <li> <p>Install dependencies using Poetry:    <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>poetry run pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-commands","title":"Development Commands","text":"<p>We use a Makefile to simplify common development tasks:</p> <ul> <li>Install dependencies: <code>make install</code></li> <li>Install for local development: <code>make install-dev</code></li> <li>Run tests: <code>make test</code></li> <li>Run tests with coverage: <code>make test-coverage</code></li> <li>Run integration tests: <code>make integration-test</code></li> <li>Run linting: <code>make lint</code></li> <li>Run type checking: <code>make type-check</code></li> <li>Format code: <code>make format</code></li> <li>Run all checks: <code>make all-checks</code></li> </ul> <p>You can also use Poetry directly: <pre><code>poetry run pytest\npoetry run mypy webdown\npoetry run flake8 webdown\npoetry run black webdown\n</code></pre></p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>This project follows PEP 8 conventions with some modifications enforced by Black and flake8:</p> <ul> <li>Use 4 spaces for indentation (enforced by Black)</li> <li>Line length is limited to 88 characters (enforced by Black)</li> <li>Follow naming conventions:</li> <li>Classes: <code>CamelCase</code></li> <li>Functions and variables: <code>snake_case</code></li> <li>Constants: <code>UPPER_CASE</code></li> </ul>"},{"location":"contributing/#type-hinting","title":"Type Hinting","text":"<p>All code should use Python type hints:</p> <pre><code>def function(parameter: str, optional_param: Optional[int] = None) -&gt; bool:\n    \"\"\"Function documentation.\"\"\"\n    ...\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>All modules, classes, and functions should have docstrings.</li> <li>Use the Google docstring format:</li> </ul> <pre><code>def function(param1: str, param2: int) -&gt; bool:\n    \"\"\"Short description of function.\n\n    Longer description explaining details if needed.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ExceptionType: When and why this exception is raised\n    \"\"\"\n</code></pre>"},{"location":"contributing/#updating-documentation","title":"Updating Documentation","text":"<p>After making changes to the codebase, especially when adding new features or modifying existing ones:</p> <ol> <li>Update the docstrings in the code with implementation details</li> <li>Update the README.md with any new command-line options or examples</li> <li>Update CHANGELOG.md with user-facing changes</li> </ol> <p>The CLI argument parser in <code>webdown/cli.py</code> is the source of truth for command-line options, and the README.md is the main user documentation.</p>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<ul> <li>Use custom exception classes defined in <code>converter.py</code></li> <li>Provide meaningful error messages</li> <li>Document all possible exceptions in docstrings</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Write tests for all new functionality</li> <li>Tests should be placed in the <code>webdown/tests</code> directory</li> <li>Follow test class naming: <code>TestClassName</code></li> <li>Follow test method naming: <code>test_functionality_being_tested</code></li> <li>Use fixtures where appropriate to reduce code duplication</li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<ul> <li>Run all tests: <code>make test</code></li> <li>Run with coverage: <code>make test-coverage</code></li> <li>Run integration tests: <code>make integration-test</code></li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository and create a feature branch</li> <li>Implement your changes, following the coding standards</li> <li>Ensure all tests pass, including new tests for your feature</li> <li>Update documentation if needed</li> <li>Submit a pull request with a clear description of the changes</li> <li>Address any feedback in code reviews</li> </ol>"},{"location":"contributing/#versioning","title":"Versioning","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for functionality added in a backward-compatible manner</li> <li>PATCH version for backward-compatible bug fixes</li> </ul>"},{"location":"contributing/#publishing-to-pypi-maintainers-only","title":"Publishing to PyPI (Maintainers Only)","text":"<p>Webdown uses GitHub Actions to automate the release process:</p> <ol> <li>Update version numbers in all files at once using the bump-version command:    <pre><code>make bump-version VERSION=0.6.0\n</code></pre>    This will automatically update:</li> <li><code>pyproject.toml</code></li> <li> <p><code>webdown/__init__.py</code></p> </li> <li> <p>Update <code>CHANGELOG.md</code> with the new version and changes (this must be done manually)</p> </li> <li> <p>Commit the version bump changes:    <pre><code>git add pyproject.toml webdown/__init__.py CHANGELOG.md\ngit commit -m \"Bump version to 0.6.0\"\n</code></pre></p> </li> <li> <p>Run the release target to verify everything and create the tag:    <pre><code>make release\n</code></pre>    If you're sure everything is correct and want to create the tag in one step:    <pre><code>make release CONFIRM=yes\n</code></pre></p> </li> <li> <p>If the release target succeeds, push the tag to trigger the release workflow:    <pre><code>git push origin v0.6.0\n</code></pre></p> </li> <li> <p>The GitHub Actions workflow will automatically:</p> </li> <li>Verify the version numbers match</li> <li>Run tests</li> <li>Build the package</li> <li>Create a GitHub release with content from CHANGELOG.md</li> <li>Publish to PyPI automatically</li> </ol> <p>For local testing before a release, you can use: - <code>make build</code> to build the package locally - <code>make publish-test</code> to publish to TestPyPI</p>"},{"location":"contributing/#troubleshooting-release-issues","title":"Troubleshooting Release Issues","text":"<p>If the release workflow fails due to version mismatch: 1. Check that versions match in <code>pyproject.toml</code> and <code>webdown/__init__.py</code> 2. If they don't match, use <code>make bump-version VERSION=x.y.z</code> to fix the discrepancy 3. Commit the changes and try the release process again</p> <p>Note: PyPI publishing uses GitHub's OIDC and PyPI's Trusted Publishers feature for secure authentication without tokens.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to this project, you agree that your contributions will be licensed under the project's MIT License (see LICENSE file).</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have any questions or need help, please open an issue or contact the maintainers directly.</p> <p>Thank you for your contributions!</p>"},{"location":"streaming-guide/","title":"Automatic Streaming for Large Web Pages","text":"<p>Webdown includes built-in support for handling large web pages through an automatic streaming mechanism. This guide explains how streaming works and when it's activated.</p>"},{"location":"streaming-guide/#understanding-streaming-mode","title":"Understanding Streaming Mode","text":"<p>For most web pages, Webdown downloads the entire HTML content at once before processing it. However, for very large web pages, this approach could use excessive memory and potentially cause issues on systems with limited resources.</p> <p>To address this, Webdown automatically switches to a streaming mode when handling large web pages.</p>"},{"location":"streaming-guide/#the-10mb-threshold","title":"The 10MB Threshold","text":"<p>Webdown uses a fixed 10MB threshold to determine when to activate streaming mode:</p> <ol> <li>When requesting a web page, Webdown first checks its size</li> <li>If the page size is less than 10MB, the entire page is downloaded at once</li> <li>If the page size is 10MB or larger, streaming mode is activated</li> </ol>"},{"location":"streaming-guide/#how-streaming-works","title":"How Streaming Works","text":"<p>When streaming mode is activated:</p> <ol> <li>Webdown downloads the page in chunks rather than all at once</li> <li>Each chunk is processed as it's received</li> <li>Progress is reported based on the amount of data downloaded</li> <li>Memory usage remains controlled even for extremely large pages</li> </ol> <p>The streaming implementation uses Python's requests library with <code>stream=True</code> and processes the response in iterations.</p>"},{"location":"streaming-guide/#progress-reporting-in-streaming-mode","title":"Progress Reporting in Streaming Mode","text":"<p>When streaming large pages, you'll notice the progress bar behaves slightly differently:</p> <ul> <li>For regular downloads, the progress bar shows both the download and processing phases</li> <li>In streaming mode, the progress bar primarily reflects the download progress</li> </ul> <p>Example terminal output for a streaming download: <pre><code>Downloading and processing https://example.com/largepage\n[\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] 100% | 15.8 MB | 00:04 remaining\nConverting to Markdown... Done!\n</code></pre></p>"},{"location":"streaming-guide/#technical-implementation","title":"Technical Implementation","text":"<p>The streaming functionality is implemented through these key components:</p> <ol> <li>Size checking: Before downloading, Webdown sends a HEAD request to determine the content size</li> <li>Threshold decision: Based on the 10MB threshold, Webdown decides whether to stream</li> <li>Chunked download: For streaming, content is downloaded in reasonable chunks (8KB by default)</li> <li>Incremental processing: Each chunk is decoded and added to the processing buffer</li> </ol> <p>This implementation balances memory efficiency with processing speed.</p>"},{"location":"streaming-guide/#common-questions","title":"Common Questions","text":""},{"location":"streaming-guide/#why-is-10mb-the-fixed-threshold","title":"Why is 10MB the fixed threshold?","text":"<p>The 10MB threshold was chosen based on: - Testing with a wide range of web pages - Balancing memory usage and performance - Ensuring compatibility with most systems</p> <p>This threshold works well for the vast majority of web pages while protecting against memory issues with extremely large pages.</p>"},{"location":"streaming-guide/#does-streaming-affect-the-output-quality","title":"Does streaming affect the output quality?","text":"<p>No. The streaming mode only changes how the content is downloaded and processed internally. The final Markdown or Claude XML output is identical regardless of whether streaming was used.</p>"},{"location":"streaming-guide/#is-streaming-slower-than-regular-downloading","title":"Is streaming slower than regular downloading?","text":"<p>Streaming can be slightly slower for pages just above the threshold because of the additional processing overhead. However, for very large pages, streaming is often more efficient and prevents potential out-of-memory errors.</p>"},{"location":"streaming-guide/#can-i-disable-streaming","title":"Can I disable streaming?","text":"<p>No, the streaming feature is automatically activated based on the page size and cannot be disabled. This design decision ensures Webdown remains robust when handling pages of any size.</p>"},{"location":"streaming-guide/#use-cases-for-large-page-handling","title":"Use Cases for Large Page Handling","text":"<p>The automatic streaming capability makes Webdown suitable for:</p> <ol> <li>Documentation sites: Handling large technical documentation</li> <li>Academic papers: Processing lengthy scientific publications</li> <li>Legal documents: Converting extensive legal texts</li> <li>Data-heavy reports: Working with pages containing large tables or datasets</li> </ol>"},{"location":"streaming-guide/#limitations","title":"Limitations","text":"<p>While streaming handles large pages well, be aware of these limitations:</p> <ol> <li>Progress reporting is less precise in streaming mode</li> <li>For extremely large pages (100MB+), processing may still take significant time</li> <li>Some websites might not report their content size correctly, affecting the streaming decision</li> </ol>"},{"location":"toc-guide/","title":"Table of Contents Generation in Webdown","text":"<p>Webdown provides powerful Table of Contents (TOC) generation capabilities for web pages you convert to Markdown or Claude XML format.</p>"},{"location":"toc-guide/#basic-usage","title":"Basic Usage","text":"<p>To generate a TOC, use the <code>--toc</code> flag:</p> <pre><code>webdown --toc https://example.com\n</code></pre> <p>This will: 1. Extract all headings (h1-h6) from the page 2. Create a nested TOC based on the heading levels 3. Add the TOC at the beginning of the output 4. Create anchor links to each heading</p>"},{"location":"toc-guide/#customizing-toc-generation","title":"Customizing TOC Generation","text":""},{"location":"toc-guide/#controlling-toc-depth","title":"Controlling TOC Depth","text":"<p>By default, Webdown includes all heading levels (h1-h6) in the TOC. You can limit the depth with <code>--toc-depth</code>:</p> <pre><code>webdown --toc --toc-depth 3 https://example.com\n</code></pre> <p>This includes only h1, h2, and h3 headings in the TOC.</p>"},{"location":"toc-guide/#toc-title","title":"TOC Title","text":"<p>By default, the TOC is titled \"Table of Contents\". You can customize this with <code>--toc-title</code>:</p> <pre><code>webdown --toc --toc-title \"Content Summary\" https://example.com\n</code></pre>"},{"location":"toc-guide/#placement","title":"Placement","text":"<p>The TOC is always placed at the beginning of the document, after any metadata but before the main content.</p>"},{"location":"toc-guide/#how-toc-links-work","title":"How TOC Links Work","text":""},{"location":"toc-guide/#link-generation","title":"Link Generation","text":"<p>For each heading in the document, Webdown:</p> <ol> <li>Extracts the heading text</li> <li>Removes HTML tags (if any remain)</li> <li>Converts the text to lowercase</li> <li>Replaces spaces with hyphens</li> <li>Removes special characters that would break Markdown links</li> <li>Creates a unique ID if duplicate headings exist (by appending -1, -2, etc.)</li> </ol> <p>For example: - Heading \"Getting Started\" becomes <code>#getting-started</code> - Heading \"Section 2.1: Examples\" becomes <code>#section-21-examples</code></p>"},{"location":"toc-guide/#duplicate-heading-handling","title":"Duplicate Heading Handling","text":"<p>Webdown automatically detects duplicate heading text and adds numeric suffixes to ensure each link is unique:</p> <pre><code>## Installation\n... content ...\n\n## Installation\n... content ...\n</code></pre> <p>The TOC will generate: <pre><code>- [Installation](#installation)\n- [Installation](#installation-1)\n</code></pre></p>"},{"location":"toc-guide/#integration-with-claude-xml","title":"Integration with Claude XML","text":"<p>When using <code>--claude-xml</code> with <code>--toc</code>, Webdown:</p> <ol> <li>Generates the TOC with proper Markdown formatting</li> <li>Places it at the beginning of the document</li> <li>Properly escapes all content within the XML tags</li> </ol> <p>Example: <pre><code>webdown --claude-xml --toc https://example.com\n</code></pre></p> <p>Output: <pre><code>&lt;answer&gt;\n# Table of Contents\n\n- [Introduction](#introduction)\n  - [Getting Started](#getting-started)\n  - [Prerequisites](#prerequisites)\n- [Main Content](#main-content)\n  - [Section 1](#section-1)\n  - [Section 2](#section-2)\n\n# Introduction\n\n## Getting Started\n\n...content continues...\n&lt;/answer&gt;\n</code></pre></p>"},{"location":"toc-guide/#technical-details","title":"Technical Details","text":""},{"location":"toc-guide/#heading-detection","title":"Heading Detection","text":"<p>Webdown extracts headings from the HTML document using a combination of: - Standard h1-h6 tags - Elements with heading roles - Elements with heading-like styling</p> <p>This ensures comprehensive heading detection across different website structures.</p>"},{"location":"toc-guide/#limitations","title":"Limitations","text":"<ul> <li>Links to headings in code blocks might not work (code blocks often contain # characters that aren't headings)</li> <li>Very complex heading texts with unusual characters might have simplified link targets</li> <li>Some Markdown viewers might have slight differences in how they generate heading IDs</li> </ul>"},{"location":"toc-guide/#best-practices","title":"Best Practices","text":"<p>For optimal TOC results:</p> <ol> <li> <p>Consider using CSS selectors to extract only the main content:    <pre><code>webdown --toc --css \"main, article, .content\" https://example.com\n</code></pre></p> </li> <li> <p>For very large documents, limit the TOC depth:    <pre><code>webdown --toc --toc-depth 2 https://example.com\n</code></pre></p> </li> <li> <p>When creating content for Claude, combine with other relevant options:    <pre><code>webdown --claude-xml --toc --compact --body-width 80 https://example.com\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/","title":"Webdown Troubleshooting Guide","text":"<p>This guide helps you understand and handle common issues when using Webdown.</p>"},{"location":"troubleshooting/#common-errors-and-solutions","title":"Common Errors and Solutions","text":""},{"location":"troubleshooting/#network-errors","title":"Network Errors","text":""},{"location":"troubleshooting/#connection-errors","title":"Connection Errors","text":"<p>Error Message: \"Failed to establish a connection to the URL: Connection refused\"</p> <p>Possible Causes: - The website is down - Your internet connection is unstable - The website is blocking requests with our default User-Agent</p> <p>Solutions: 1. Check if the website is accessible in your browser 2. Try again in a few minutes if the site might be temporarily down 3. Use a custom User-Agent with the <code>--user-agent</code> flag:    <pre><code>webdown --user-agent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\" https://example.com\n</code></pre></p>"},{"location":"troubleshooting/#timeout-errors","title":"Timeout Errors","text":"<p>Error Message: \"Request timed out after X seconds\"</p> <p>Possible Causes: - The website is slow to respond - The website has large resources that take time to load - Your internet connection is slow</p> <p>Solutions: 1. Increase the timeout with the <code>--timeout</code> flag:    <pre><code>webdown --timeout 60 https://example.com\n</code></pre> 2. Try again when your internet connection is more stable</p>"},{"location":"troubleshooting/#invalid-url-errors","title":"Invalid URL Errors","text":"<p>Error Message: \"Invalid URL: The URL must begin with http:// or https://\"</p> <p>Solution: Ensure your URL starts with either <code>http://</code> or <code>https://</code>. Webdown requires fully-formed URLs.</p>"},{"location":"troubleshooting/#css-selector-errors","title":"CSS Selector Errors","text":"<p>Error Message: \"Invalid CSS selector: Not a valid CSS selector\" or \"CSS selector did not match any elements\"</p> <p>Possible Causes: - The CSS selector syntax is invalid - The selector doesn't match any elements on the page - The page structure has changed since you last used the selector</p> <p>Solutions: 1. Check the syntax of your CSS selector 2. Use browser developer tools to verify your selector matches elements on the current page 3. Try a broader selector:    <pre><code>webdown --css \"main, article, .content\" https://example.com\n</code></pre></p>"},{"location":"troubleshooting/#content-extraction-errors","title":"Content Extraction Errors","text":"<p>Error Message: \"Failed to extract content\" or \"No content found after extraction\"</p> <p>Possible Causes: - The page uses JavaScript to render content (Webdown doesn't execute JavaScript) - The CSS selector didn't match any content-containing elements - The page structure is unusual</p> <p>Solutions: 1. Try without a CSS selector to get the entire page 2. Use a browser developer tool to find a better CSS selector 3. For JavaScript-heavy sites, consider using a different tool that can execute JavaScript</p>"},{"location":"troubleshooting/#large-file-handling","title":"Large File Handling","text":"<p>When processing very large web pages (&gt;10MB), Webdown automatically switches to streaming mode. You might notice:</p> <ul> <li>Progress reporting is less precise</li> <li>Memory usage is optimized but processing might be slower</li> </ul> <p>This behavior is normal and helps handle large sites without excessive memory usage.</p>"},{"location":"troubleshooting/#markdown-formatting-issues","title":"Markdown Formatting Issues","text":""},{"location":"troubleshooting/#table-of-contents-problems","title":"Table of Contents Problems","text":"<p>Issue: Table of contents links are not working correctly</p> <p>Possible Causes: - Special characters in headings - Duplicate heading names - Complex formatting in headings</p> <p>Solutions: 1. Use the <code>--toc-depth</code> flag to limit TOC depth:    <pre><code>webdown --toc --toc-depth 2 https://example.com\n</code></pre> 2. For files with many similar headings, try post-processing with a text editor</p>"},{"location":"troubleshooting/#code-block-formatting","title":"Code Block Formatting","text":"<p>Issue: Code blocks are not formatted correctly</p> <p>Possible Causes: - The original HTML doesn't use standard code tags - The code has special formatting that's lost in conversion</p> <p>Solutions: 1. Use <code>--preserve-emphasis</code> to maintain more formatting:    <pre><code>webdown --preserve-emphasis https://example.com\n</code></pre> 2. For Claude XML output, code blocks are automatically wrapped in <code>&lt;answer&gt;</code> tags with language information preserved</p>"},{"location":"troubleshooting/#claude-xml-specific-issues","title":"Claude XML Specific Issues","text":""},{"location":"troubleshooting/#xml-validation-errors","title":"XML Validation Errors","text":"<p>Issue: Output XML is not recognized by Claude</p> <p>Possible Causes: - Unclosed XML tags in the content - Malformed XML due to special characters - Invalid HTML in the source document</p> <p>Solutions: 1. Use the <code>--compact</code> option to reduce extraneous whitespace:    <pre><code>webdown --claude-xml --compact https://example.com\n</code></pre> 2. Check if the source HTML has valid structure 3. For complex pages, try extracting specific sections with CSS selectors:    <pre><code>webdown --claude-xml --css \"main, article\" https://example.com\n</code></pre></p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you continue to experience issues not covered in this guide:</p> <ol> <li>Check the GitHub Issues to see if your problem has been reported</li> <li>If not, create a new issue with:</li> <li>The command you ran</li> <li>The complete error message</li> <li>The URL you were trying to process (if not private)</li> <li>Your operating system and Python version</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Webdown provides a simple API for converting web pages to Markdown and crawling entire websites. The main modules are:</p>"},{"location":"api/#modules","title":"Modules","text":"<ul> <li>Converter - Core functionality for HTML to Markdown conversion</li> <li>CLI - Command-line interface for the package</li> </ul>"},{"location":"api/#quick-start","title":"Quick Start","text":""},{"location":"api/#single-page-conversion","title":"Single Page Conversion","text":"<pre><code>from webdown.converter import convert_url_to_markdown\n\n# Basic usage\nmarkdown = convert_url_to_markdown(\"https://example.com\")\n\n# With options\nmarkdown = convert_url_to_markdown(\n    url=\"https://example.com\",\n    include_toc=True,\n    compact_output=True,\n    body_width=80\n)\n\n# Save to file\nwith open(\"output.md\", \"w\") as f:\n    f.write(markdown)\n</code></pre>"},{"location":"api/#multi-page-crawling","title":"Multi-Page Crawling","text":"<pre><code>from webdown import crawl, CrawlerConfig, ScopeType\n\n# Configure the crawler\nconfig = CrawlerConfig(\n    seed_urls=[\"https://docs.example.com/\"],\n    output_dir=\"./output/\",\n    max_depth=3,\n    delay_seconds=1.0,\n    scope=ScopeType.SAME_SUBDOMAIN,\n)\n\n# Crawl the site\nresult = crawl(config)\n\nprint(f\"Crawled {result.successful_count} pages\")\nfor page in result.pages:\n    print(f\"  {page.url} -&gt; {page.output_path}\")\n</code></pre>"},{"location":"api/#crawl-from-sitemap","title":"Crawl from Sitemap","text":"<pre><code>from webdown import crawl_from_sitemap, CrawlerConfig\n\nconfig = CrawlerConfig(\n    seed_urls=[],  # Not used for sitemap crawl\n    output_dir=\"./output/\",\n)\n\nresult = crawl_from_sitemap(\n    \"https://docs.example.com/sitemap.xml\",\n    config\n)\n</code></pre> <p>For more details, see the Converter API documentation.</p>"},{"location":"api/cli/","title":"Command-Line Interface","text":"<p>Command-line interface for webdown.</p> <p>This module provides the command-line interface (CLI) for Webdown, a tool for converting web pages or local HTML files to clean, readable Markdown format. The CLI allows users to customize various aspects of the conversion process, from content selection to formatting options.</p> <p>For a complete reference, see the CLI Reference documentation.</p>"},{"location":"api/cli/#webdown.cli--basic-usage","title":"Basic Usage","text":"<p>The most basic usage is to convert a URL:</p> <pre><code>webdown -u https://example.com\n</code></pre> <p>Or convert a local HTML file:</p> <pre><code>webdown -f ./page.html\n</code></pre> <p>This will convert the content to Markdown, displaying the result to stdout. To save the output to a file:</p> <pre><code>webdown -u https://example.com -o output.md\nwebdown -f ./page.html -o output.md\n</code></pre>"},{"location":"api/cli/#webdown.cli--crawl-mode","title":"Crawl Mode","text":"<p>To crawl multiple pages from a website:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre> <p>Or use a sitemap:</p> <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre>"},{"location":"api/cli/#webdown.cli--common-options","title":"Common Options","text":"<p>The CLI offers various options to customize the conversion:</p>"},{"location":"api/cli/#webdown.cli--source-options","title":"Source Options","text":"<ul> <li><code>-u, --url URL</code>: URL of the web page to convert</li> <li><code>-f, --file FILE</code>: Path to local HTML file to convert</li> </ul>"},{"location":"api/cli/#webdown.cli--inputoutput-options","title":"Input/Output Options","text":"<ul> <li><code>-o, --output FILE</code>: Write output to FILE instead of stdout</li> <li><code>-p, --progress</code>: Show download progress bar (only for URL downloads)</li> </ul>"},{"location":"api/cli/#webdown.cli--content-options","title":"Content Options","text":"<ul> <li><code>-t, --toc</code>: Generate a table of contents based on headings</li> <li><code>-L, --no-links</code>: Strip hyperlinks, converting them to plain text</li> <li><code>-I, --no-images</code>: Exclude images from the output</li> <li><code>-s, --css SELECTOR</code>: Extract only content matching the CSS selector (e.g., \"main\")</li> <li><code>-c, --compact</code>: Remove excessive blank lines from the output</li> <li><code>-w, --width N</code>: Set line width for wrapped text (0 for no wrapping)</li> <li><code>-V, --version</code>: Show version information and exit</li> <li><code>-h, --help</code>: Show help message and exit</li> </ul> <p>Note: For large web pages (over 10MB), webdown automatically uses streaming mode to optimize memory usage.</p>"},{"location":"api/cli/#webdown.cli--claude-xml-options","title":"Claude XML Options","text":"<p>Options for generating Claude XML format, optimized for use with Claude AI:</p> <ul> <li><code>--claude-xml</code>: Output in Claude XML format instead of Markdown</li> <li><code>--metadata</code>: Include metadata section in XML (default: True)</li> <li><code>--no-metadata</code>: Exclude metadata section from XML</li> <li><code>--no-date</code>: Don't include current date in metadata</li> </ul>"},{"location":"api/cli/#webdown.cli--example-scenarios","title":"Example Scenarios","text":""},{"location":"api/cli/#webdown.cli--web-page-conversion-examples","title":"Web Page Conversion Examples","text":"<ol> <li> <p>Basic conversion with a table of contents:    <pre><code>webdown -u https://example.com -t -o output.md\n</code></pre></p> </li> <li> <p>Extract only the main content area with compact output and text wrapping:    <pre><code>webdown -u https://example.com -s \"main\" -c -w 80 -o output.md\n</code></pre></p> </li> <li> <p>Create a plain text version (no links or images):    <pre><code>webdown -u https://example.com -L -I -o text_only.md\n</code></pre></p> </li> <li> <p>Show download progress for large pages:    <pre><code>webdown -u https://example.com -p -o output.md\n</code></pre></p> </li> <li> <p>Extract content from a specific div:    <pre><code>webdown -u https://example.com -s \"#content\" -o output.md\n</code></pre></p> </li> <li> <p>Process a large webpage with progress bar (streaming is automatic for large pages):    <pre><code>webdown -u https://example.com -p\n</code></pre></p> </li> <li> <p>Generate output in Claude XML format for use with Claude AI:    <pre><code>webdown -u https://example.com -s \"main\" --claude-xml -o output.xml\n</code></pre></p> </li> <li> <p>Create Claude XML without metadata:    <pre><code>webdown -u https://example.com --claude-xml --no-metadata -o output.xml\n</code></pre></p> </li> <li> <p>Complete example with multiple options:    <pre><code>webdown -u https://example.com -s \"main\" -t -c -w 80 -p -o output.md\n</code></pre></p> </li> </ol>"},{"location":"api/cli/#webdown.cli--local-html-file-conversion-examples","title":"Local HTML File Conversion Examples","text":"<ol> <li> <p>Convert a local HTML file to Markdown:    <pre><code>webdown -f ./page.html -o output.md\n</code></pre></p> </li> <li> <p>Convert a local file with table of contents:    <pre><code>webdown -f ./page.html -t -o output.md\n</code></pre></p> </li> <li> <p>Extract only main content from a local file:    <pre><code>webdown -f ./page.html -s \"main\" -o output.md\n</code></pre></p> </li> <li> <p>Create plain text from a local file (no links or images):    <pre><code>webdown -f ./page.html -L -I -o text_only.md\n</code></pre></p> </li> <li> <p>Convert local file to Claude XML format:    <pre><code>webdown -f ./page.html --claude-xml -o output.xml\n</code></pre></p> </li> <li> <p>Complete local file example with multiple options:    <pre><code>webdown -f ./page.html -s \"main\" -t -c -w 80 -o output.md\n</code></pre></p> </li> </ol>"},{"location":"api/cli/#webdown.cli--crawl-mode-examples","title":"Crawl Mode Examples","text":"<ol> <li> <p>Basic crawl from a seed URL:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre></p> </li> <li> <p>Crawl with depth and delay settings:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/ --max-depth 5 --delay 2.0\n</code></pre></p> </li> <li> <p>Crawl from a sitemap:    <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre></p> </li> <li> <p>Crawl with content options:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/ -s \"main\" --claude-xml\n</code></pre></p> </li> </ol> <p>The entry point is the <code>main()</code> function, which is called when the command <code>webdown</code> is executed.</p>"},{"location":"api/cli/#functions-reference","title":"Functions Reference","text":"<p>Command-line interface for webdown.</p> <p>This module provides the command-line interface (CLI) for Webdown, a tool for converting web pages or local HTML files to clean, readable Markdown format. The CLI allows users to customize various aspects of the conversion process, from content selection to formatting options.</p> <p>For a complete reference, see the CLI Reference documentation.</p>"},{"location":"api/cli/#webdown.cli--basic-usage","title":"Basic Usage","text":"<p>The most basic usage is to convert a URL:</p> <pre><code>webdown -u https://example.com\n</code></pre> <p>Or convert a local HTML file:</p> <pre><code>webdown -f ./page.html\n</code></pre> <p>This will convert the content to Markdown, displaying the result to stdout. To save the output to a file:</p> <pre><code>webdown -u https://example.com -o output.md\nwebdown -f ./page.html -o output.md\n</code></pre>"},{"location":"api/cli/#webdown.cli--crawl-mode","title":"Crawl Mode","text":"<p>To crawl multiple pages from a website:</p> <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre> <p>Or use a sitemap:</p> <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre>"},{"location":"api/cli/#webdown.cli--common-options","title":"Common Options","text":"<p>The CLI offers various options to customize the conversion:</p>"},{"location":"api/cli/#webdown.cli--source-options","title":"Source Options","text":"<ul> <li><code>-u, --url URL</code>: URL of the web page to convert</li> <li><code>-f, --file FILE</code>: Path to local HTML file to convert</li> </ul>"},{"location":"api/cli/#webdown.cli--inputoutput-options","title":"Input/Output Options","text":"<ul> <li><code>-o, --output FILE</code>: Write output to FILE instead of stdout</li> <li><code>-p, --progress</code>: Show download progress bar (only for URL downloads)</li> </ul>"},{"location":"api/cli/#webdown.cli--content-options","title":"Content Options","text":"<ul> <li><code>-t, --toc</code>: Generate a table of contents based on headings</li> <li><code>-L, --no-links</code>: Strip hyperlinks, converting them to plain text</li> <li><code>-I, --no-images</code>: Exclude images from the output</li> <li><code>-s, --css SELECTOR</code>: Extract only content matching the CSS selector (e.g., \"main\")</li> <li><code>-c, --compact</code>: Remove excessive blank lines from the output</li> <li><code>-w, --width N</code>: Set line width for wrapped text (0 for no wrapping)</li> <li><code>-V, --version</code>: Show version information and exit</li> <li><code>-h, --help</code>: Show help message and exit</li> </ul> <p>Note: For large web pages (over 10MB), webdown automatically uses streaming mode to optimize memory usage.</p>"},{"location":"api/cli/#webdown.cli--claude-xml-options","title":"Claude XML Options","text":"<p>Options for generating Claude XML format, optimized for use with Claude AI:</p> <ul> <li><code>--claude-xml</code>: Output in Claude XML format instead of Markdown</li> <li><code>--metadata</code>: Include metadata section in XML (default: True)</li> <li><code>--no-metadata</code>: Exclude metadata section from XML</li> <li><code>--no-date</code>: Don't include current date in metadata</li> </ul>"},{"location":"api/cli/#webdown.cli--example-scenarios","title":"Example Scenarios","text":""},{"location":"api/cli/#webdown.cli--web-page-conversion-examples","title":"Web Page Conversion Examples","text":"<ol> <li> <p>Basic conversion with a table of contents:    <pre><code>webdown -u https://example.com -t -o output.md\n</code></pre></p> </li> <li> <p>Extract only the main content area with compact output and text wrapping:    <pre><code>webdown -u https://example.com -s \"main\" -c -w 80 -o output.md\n</code></pre></p> </li> <li> <p>Create a plain text version (no links or images):    <pre><code>webdown -u https://example.com -L -I -o text_only.md\n</code></pre></p> </li> <li> <p>Show download progress for large pages:    <pre><code>webdown -u https://example.com -p -o output.md\n</code></pre></p> </li> <li> <p>Extract content from a specific div:    <pre><code>webdown -u https://example.com -s \"#content\" -o output.md\n</code></pre></p> </li> <li> <p>Process a large webpage with progress bar (streaming is automatic for large pages):    <pre><code>webdown -u https://example.com -p\n</code></pre></p> </li> <li> <p>Generate output in Claude XML format for use with Claude AI:    <pre><code>webdown -u https://example.com -s \"main\" --claude-xml -o output.xml\n</code></pre></p> </li> <li> <p>Create Claude XML without metadata:    <pre><code>webdown -u https://example.com --claude-xml --no-metadata -o output.xml\n</code></pre></p> </li> <li> <p>Complete example with multiple options:    <pre><code>webdown -u https://example.com -s \"main\" -t -c -w 80 -p -o output.md\n</code></pre></p> </li> </ol>"},{"location":"api/cli/#webdown.cli--local-html-file-conversion-examples","title":"Local HTML File Conversion Examples","text":"<ol> <li> <p>Convert a local HTML file to Markdown:    <pre><code>webdown -f ./page.html -o output.md\n</code></pre></p> </li> <li> <p>Convert a local file with table of contents:    <pre><code>webdown -f ./page.html -t -o output.md\n</code></pre></p> </li> <li> <p>Extract only main content from a local file:    <pre><code>webdown -f ./page.html -s \"main\" -o output.md\n</code></pre></p> </li> <li> <p>Create plain text from a local file (no links or images):    <pre><code>webdown -f ./page.html -L -I -o text_only.md\n</code></pre></p> </li> <li> <p>Convert local file to Claude XML format:    <pre><code>webdown -f ./page.html --claude-xml -o output.xml\n</code></pre></p> </li> <li> <p>Complete local file example with multiple options:    <pre><code>webdown -f ./page.html -s \"main\" -t -c -w 80 -o output.md\n</code></pre></p> </li> </ol>"},{"location":"api/cli/#webdown.cli--crawl-mode-examples","title":"Crawl Mode Examples","text":"<ol> <li> <p>Basic crawl from a seed URL:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/\n</code></pre></p> </li> <li> <p>Crawl with depth and delay settings:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/ --max-depth 5 --delay 2.0\n</code></pre></p> </li> <li> <p>Crawl from a sitemap:    <pre><code>webdown crawl --sitemap https://docs.example.com/sitemap.xml -o ./output/\n</code></pre></p> </li> <li> <p>Crawl with content options:    <pre><code>webdown crawl https://docs.example.com/ -o ./output/ -s \"main\" --claude-xml\n</code></pre></p> </li> </ol> <p>The entry point is the <code>main()</code> function, which is called when the command <code>webdown</code> is executed.</p>"},{"location":"api/cli/#webdown.cli-functions","title":"Functions","text":""},{"location":"api/cli/#webdown.cli.main","title":"<code>main(args: Optional[List[str]] = None) -&gt; int</code>","text":"<p>Execute the webdown command-line interface.</p> <p>This function is the main entry point for the webdown command-line tool. It handles the entire workflow: 1. Parsing command-line arguments 2. Converting the content (URL or file) to Markdown with the specified options 3. Writing the output to a file or stdout 4. Error handling and reporting</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Optional[List[str]]</code> <p>Command line arguments as a list of strings. If None, defaults to   sys.argv[1:] (the command-line arguments passed to the script).</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code: 0 for success, 1 for errors</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main(['-u', 'https://example.com'])  # Convert URL and print to stdout\n0\n&gt;&gt;&gt; main(['-u', 'https://example.com', '-o', 'output.md'])  # Write URL to file\n0\n&gt;&gt;&gt; main(['-f', 'page.html'])  # Convert file and print to stdout\n0\n&gt;&gt;&gt; main(['-f', 'page.html', '-o', 'output.md'])  # Write file to file\n0\n&gt;&gt;&gt; main(['-u', 'invalid-url'])  # Handle error\n1\n</code></pre> Source code in <code>webdown/cli.py</code> <pre><code>def main(args: Optional[List[str]] = None) -&gt; int:\n    \"\"\"Execute the webdown command-line interface.\n\n    This function is the main entry point for the webdown command-line tool.\n    It handles the entire workflow:\n    1. Parsing command-line arguments\n    2. Converting the content (URL or file) to Markdown with the specified options\n    3. Writing the output to a file or stdout\n    4. Error handling and reporting\n\n    Args:\n        args: Command line arguments as a list of strings. If None, defaults to\n              sys.argv[1:] (the command-line arguments passed to the script).\n\n    Returns:\n        Exit code: 0 for success, 1 for errors\n\n    Examples:\n        &gt;&gt;&gt; main(['-u', 'https://example.com'])  # Convert URL and print to stdout\n        0\n        &gt;&gt;&gt; main(['-u', 'https://example.com', '-o', 'output.md'])  # Write URL to file\n        0\n        &gt;&gt;&gt; main(['-f', 'page.html'])  # Convert file and print to stdout\n        0\n        &gt;&gt;&gt; main(['-f', 'page.html', '-o', 'output.md'])  # Write file to file\n        0\n        &gt;&gt;&gt; main(['-u', 'invalid-url'])  # Handle error\n        1\n    \"\"\"\n    try:\n        # Parse command-line arguments\n        parsed_args = parse_args(args)\n\n        # Handle crawl subcommand\n        if parsed_args.command == \"crawl\":\n            return _execute_crawl(parsed_args)\n\n        # If neither URL nor file provided, show help\n        if parsed_args.url is None and parsed_args.file is None:\n            # This will print help and exit\n            parse_args([\"-h\"])  # pragma: no cover\n            return 0  # pragma: no cover - unreachable after SystemExit\n\n        # Process content and generate output\n        content, output_path = _convert_to_selected_format(parsed_args)\n\n        # Write output to file or stdout\n        write_output(content, output_path)\n\n        return 0\n\n    except Exception as e:\n        # Format and display error message\n        formatted_error = format_error_for_cli(e)\n        sys.stderr.write(f\"{formatted_error}\\n\")\n        return 1\n</code></pre>"},{"location":"api/cli/#webdown.cli.parse_args","title":"<code>parse_args(args: Optional[List[str]] = None) -&gt; argparse.Namespace</code>","text":"<p>Parse command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Optional[List[str]]</code> <p>Command line arguments (defaults to sys.argv[1:] if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>Parsed arguments</p> Source code in <code>webdown/cli.py</code> <pre><code>def parse_args(args: Optional[List[str]] = None) -&gt; argparse.Namespace:\n    \"\"\"Parse command line arguments.\n\n    Args:\n        args: Command line arguments (defaults to sys.argv[1:] if None)\n\n    Returns:\n        Parsed arguments\n    \"\"\"\n    parser = create_argument_parser()\n    return parser.parse_args(args)\n</code></pre>"},{"location":"api/converter/","title":"Core API Reference","text":"<p>This page documents the main API functions and classes provided by Webdown.</p>"},{"location":"api/converter/#main-functions","title":"Main Functions","text":"<p>HTML to Markdown and Claude XML conversion functionality.</p> <p>This module serves as the main entry point for the webdown package, providing the primary functions for converting web content to Markdown and Claude XML formats.</p> <p>The conversion process involves multiple steps: 1. Fetch or read HTML content (from URL or local file) 2. Convert HTML to Markdown 3. Optionally convert Markdown to Claude XML format</p> <p>Key functions: - convert_url: Convert web content to Markdown or XML - convert_file: Convert local HTML file to Markdown or XML</p>"},{"location":"api/converter/#webdown.converter-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.converter.html_to_markdown","title":"<code>html_to_markdown(html: str, config: WebdownConfig) -&gt; str</code>","text":"<p>Convert HTML to Markdown with formatting options.</p> <p>This function takes HTML content and converts it to Markdown format based on the provided configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>HTML content to convert</p> required <code>config</code> <code>WebdownConfig</code> <p>Configuration options for the conversion</p> required <p>Returns:</p> Type Description <code>str</code> <p>Converted Markdown content</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; html = \"&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content with &lt;a href='#'&gt;link&lt;/a&gt;&lt;/p&gt;\"\n&gt;&gt;&gt; config = WebdownConfig()\n&gt;&gt;&gt; print(html_to_markdown(html, config))\n# Title\n</code></pre> <p>Content with link</p> <pre><code>&gt;&gt;&gt; config = WebdownConfig(include_links=False)\n&gt;&gt;&gt; print(html_to_markdown(html, config))\n# Title\n</code></pre> <p>Content with link</p> Source code in <code>webdown/markdown_converter.py</code> <pre><code>def html_to_markdown(\n    html: str,\n    config: WebdownConfig,\n) -&gt; str:\n    \"\"\"Convert HTML to Markdown with formatting options.\n\n    This function takes HTML content and converts it to Markdown format\n    based on the provided configuration object.\n\n    Args:\n        html: HTML content to convert\n        config: Configuration options for the conversion\n\n    Returns:\n        Converted Markdown content\n\n    Examples:\n        &gt;&gt;&gt; html = \"&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content with &lt;a href='#'&gt;link&lt;/a&gt;&lt;/p&gt;\"\n        &gt;&gt;&gt; config = WebdownConfig()\n        &gt;&gt;&gt; print(html_to_markdown(html, config))\n        # Title\n\n        Content with [link](#)\n\n        &gt;&gt;&gt; config = WebdownConfig(include_links=False)\n        &gt;&gt;&gt; print(html_to_markdown(html, config))\n        # Title\n\n        Content with link\n    \"\"\"\n    # Validate all configuration parameters\n    _validate_config(config)\n\n    # Extract specific content by CSS selector if provided\n    if config.css_selector:\n        html = extract_content_with_css(html, config.css_selector)\n\n    # Configure and run html2text\n    converter = _configure_html2text(config)\n    markdown = converter.handle(html)\n\n    # Clean up the markdown\n    markdown = clean_markdown(markdown, config.document_options.compact_output)\n\n    # Add table of contents if requested\n    if config.document_options.include_toc:\n        markdown = generate_table_of_contents(markdown)\n\n    return str(markdown)\n</code></pre>"},{"location":"api/converter/#webdown.converter.markdown_to_claude_xml","title":"<code>markdown_to_claude_xml(markdown: str, source_url: Optional[str] = None, include_metadata: bool = True) -&gt; str</code>","text":"<p>Convert Markdown content to Claude XML format.</p> <p>This function converts Markdown content to a structured XML format suitable for use with Claude AI models. It handles elements like headings, paragraphs, and code blocks, organizing them into a hierarchical XML document.</p> <p>Parameters:</p> Name Type Description Default <code>markdown</code> <code>str</code> <p>Markdown content to convert</p> required <code>source_url</code> <code>Optional[str]</code> <p>Source URL for the content (for metadata)</p> <code>None</code> <code>include_metadata</code> <code>bool</code> <p>Whether to include metadata section (title, source, date)</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Claude XML formatted content</p> Source code in <code>webdown/xml_converter.py</code> <pre><code>def markdown_to_claude_xml(\n    markdown: str,\n    source_url: Optional[str] = None,\n    include_metadata: bool = True,\n) -&gt; str:\n    \"\"\"Convert Markdown content to Claude XML format.\n\n    This function converts Markdown content to a structured XML format\n    suitable for use with Claude AI models. It handles elements like\n    headings, paragraphs, and code blocks, organizing them into a\n    hierarchical XML document.\n\n    Args:\n        markdown: Markdown content to convert\n        source_url: Source URL for the content (for metadata)\n        include_metadata: Whether to include metadata section (title, source, date)\n\n    Returns:\n        Claude XML formatted content\n    \"\"\"\n    xml_parts = []\n\n    # Use a fixed document tag - simplifying configuration\n    doc_tag = \"claude_documentation\"\n\n    # Root element\n    xml_parts.append(f\"&lt;{doc_tag}&gt;\")\n\n    # Extract title\n    title = extract_markdown_title(markdown)\n\n    # Add metadata if requested\n    if include_metadata:\n        xml_parts.extend(generate_metadata_xml(title, source_url))\n\n    # Begin content section\n    xml_parts.append(indent_xml(\"&lt;content&gt;\", 1))\n\n    # Process all content by section\n\n    # Extract all section headings\n    section_matches = list(re.finditer(r\"^(#+\\s+)(.+?)$\", markdown, re.MULTILINE))\n\n    if section_matches:\n        # Process each section including content following the heading\n        for i, match in enumerate(section_matches):\n            heading_start = match.start()\n            heading = match.group(0)\n            # If this is the last heading, content goes to the end\n            if i == len(section_matches) - 1:\n                content = markdown[heading_start + len(heading) :].strip()\n            else:\n                # Otherwise content goes until the next heading\n                next_heading_start = section_matches[i + 1].start()\n                content = markdown[\n                    heading_start + len(heading) : next_heading_start\n                ].strip()\n\n            # Create section with heading and content\n            section_xml = []\n            section_xml.append(indent_xml(\"&lt;section&gt;\", 2))\n            section_xml.append(\n                indent_xml(\n                    f\"&lt;heading&gt;{escape_xml(match.group(2).strip())}&lt;/heading&gt;\", 3\n                )\n            )\n\n            # Process content inside this section\n            if content:\n                section_xml.extend(_process_paragraphs(content, 3))\n\n            section_xml.append(indent_xml(\"&lt;/section&gt;\", 2))\n            xml_parts.extend(section_xml)\n\n        # Process content before the first heading (if any)\n        if section_matches[0].start() &gt; 0:\n            pre_content = markdown[: section_matches[0].start()].strip()\n            if pre_content:\n                # Add pre-heading content at the beginning\n                pre_parts = _process_paragraphs(pre_content, 2)\n\n                xml_parts = xml_parts[:2] + pre_parts + xml_parts[2:]\n    else:\n        # No headings - just process all content\n        xml_parts.extend(_process_paragraphs(markdown, 2))\n\n    # Close content and root\n    xml_parts.append(indent_xml(\"&lt;/content&gt;\", 1))\n    xml_parts.append(f\"&lt;/{doc_tag}&gt;\")\n\n    return \"\\n\".join(xml_parts)\n</code></pre>"},{"location":"api/converter/#configuration-classes","title":"Configuration Classes","text":"<p>Configuration options for HTML to Markdown conversion.</p> <p>This class centralizes all configuration options for the conversion process, focusing on the most useful options for LLM documentation processing.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>Optional[str]</code> <p>URL of the web page to convert</p> <code>file_path</code> <code>Optional[str]</code> <p>Path to local HTML file to convert</p> <code>include_links</code> <code>bool</code> <p>Whether to include hyperlinks (True) or plain text (False)</p> <code>include_images</code> <code>bool</code> <p>Whether to include images (True) or exclude them</p> <code>css_selector</code> <code>Optional[str]</code> <p>CSS selector to extract specific content</p> <code>show_progress</code> <code>bool</code> <p>Whether to display a progress bar during download</p> <code>format</code> <code>OutputFormat</code> <p>Output format (Markdown or Claude XML)</p> <code>document_options</code> <code>DocumentOptions</code> <p>Document structure configuration</p> Source code in <code>webdown/config.py</code> <pre><code>@dataclass\nclass WebdownConfig:\n    \"\"\"Configuration options for HTML to Markdown conversion.\n\n    This class centralizes all configuration options for the conversion process,\n    focusing on the most useful options for LLM documentation processing.\n\n    Attributes:\n        url (Optional[str]): URL of the web page to convert\n        file_path (Optional[str]): Path to local HTML file to convert\n        include_links (bool): Whether to include hyperlinks (True) or plain text (False)\n        include_images (bool): Whether to include images (True) or exclude them\n        css_selector (Optional[str]): CSS selector to extract specific content\n        show_progress (bool): Whether to display a progress bar during download\n        format (OutputFormat): Output format (Markdown or Claude XML)\n        document_options (DocumentOptions): Document structure configuration\n    \"\"\"\n\n    # Source options\n    url: Optional[str] = None\n    file_path: Optional[str] = None\n    show_progress: bool = False\n\n    # Content options\n    include_links: bool = True\n    include_images: bool = True\n    css_selector: Optional[str] = None\n\n    # Output options\n    format: OutputFormat = OutputFormat.MARKDOWN\n\n    # We need to use field with default_factory to avoid mutable default value\n    document_options: DocumentOptions = field(default_factory=DocumentOptions)\n</code></pre> <p>Configuration for document output structure.</p> <p>This class contains settings that affect the structure of the generated document, independent of the output format.</p> <p>Attributes:</p> Name Type Description <code>include_toc</code> <code>bool</code> <p>Whether to generate a table of contents</p> <code>compact_output</code> <code>bool</code> <p>Whether to remove excessive blank lines</p> <code>body_width</code> <code>int</code> <p>Maximum line length for wrapping (0 for no wrapping)</p> <code>include_metadata</code> <code>bool</code> <p>Include metadata section with title, source URL, date (only applies to Claude XML format)</p> Source code in <code>webdown/config.py</code> <pre><code>@dataclass\nclass DocumentOptions:\n    \"\"\"Configuration for document output structure.\n\n    This class contains settings that affect the structure of the generated document,\n    independent of the output format.\n\n    Attributes:\n        include_toc (bool): Whether to generate a table of contents\n        compact_output (bool): Whether to remove excessive blank lines\n        body_width (int): Maximum line length for wrapping (0 for no wrapping)\n        include_metadata (bool): Include metadata section with title, source URL, date\n            (only applies to Claude XML format)\n    \"\"\"\n\n    include_toc: bool = False\n    compact_output: bool = False\n    body_width: int = 0\n    include_metadata: bool = True\n</code></pre>"},{"location":"api/converter/#webdown.config.WebdownConfig-attributes","title":"Attributes","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.css_selector","title":"<code>css_selector: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.document_options","title":"<code>document_options: DocumentOptions = field(default_factory=DocumentOptions)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.file_path","title":"<code>file_path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.format","title":"<code>format: OutputFormat = OutputFormat.MARKDOWN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.include_images","title":"<code>include_images: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.include_links","title":"<code>include_links: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.show_progress","title":"<code>show_progress: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.url","title":"<code>url: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.WebdownConfig-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.config.WebdownConfig.__init__","title":"<code>__init__(url: Optional[str] = None, file_path: Optional[str] = None, show_progress: bool = False, include_links: bool = True, include_images: bool = True, css_selector: Optional[str] = None, format: OutputFormat = OutputFormat.MARKDOWN, document_options: DocumentOptions = DocumentOptions()) -&gt; None</code>","text":""},{"location":"api/converter/#webdown.config.DocumentOptions-attributes","title":"Attributes","text":""},{"location":"api/converter/#webdown.config.DocumentOptions.body_width","title":"<code>body_width: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.DocumentOptions.compact_output","title":"<code>compact_output: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.DocumentOptions.include_metadata","title":"<code>include_metadata: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.DocumentOptions.include_toc","title":"<code>include_toc: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converter/#webdown.config.DocumentOptions-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.config.DocumentOptions.__init__","title":"<code>__init__(include_toc: bool = False, compact_output: bool = False, body_width: int = 0, include_metadata: bool = True) -&gt; None</code>","text":""},{"location":"api/converter/#html-parsing","title":"HTML Parsing","text":"<p>HTML parsing and fetching functionality.</p> <p>This module handles fetching web content and basic HTML parsing: - URL validation and verification - HTML fetching with proper error handling and progress tracking - HTML file reading from local filesystem - Content extraction with CSS selectors - Streaming support for large web pages</p> <p>The primary functions are fetch_url() for retrieving HTML content from web, read_html_file() for reading HTML from local files, and extract_content_with_css() for selecting specific parts of HTML.</p>"},{"location":"api/converter/#webdown.html_parser-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.html_parser.fetch_url","title":"<code>fetch_url(url: str, show_progress: bool = False) -&gt; str</code>","text":"<p>Fetch HTML content from URL with optional progress bar.</p> <p>This is a simplified wrapper around fetch_url_with_progress with default parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch</p> required <code>show_progress</code> <code>bool</code> <p>Whether to display a progress bar during download</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML content as string</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If URL is invalid or content cannot be fetched</p> Source code in <code>webdown/html_parser.py</code> <pre><code>def fetch_url(url: str, show_progress: bool = False) -&gt; str:\n    \"\"\"Fetch HTML content from URL with optional progress bar.\n\n    This is a simplified wrapper around fetch_url_with_progress with default parameters.\n\n    Args:\n        url: URL to fetch\n        show_progress: Whether to display a progress bar during download\n\n    Returns:\n        HTML content as string\n\n    Raises:\n        WebdownError: If URL is invalid or content cannot be fetched\n    \"\"\"\n    # Validate URL for backward compatibility with tests\n    # In normal usage, URL is already validated by _get_normalized_config\n    try:\n        validate_url(url)\n    except ValueError as e:\n        raise WebdownError(str(e), code=ErrorCode.URL_INVALID)\n\n    return fetch_url_with_progress(url, show_progress, chunk_size=1024, timeout=10)\n</code></pre>"},{"location":"api/converter/#webdown.html_parser.fetch_url_with_progress","title":"<code>fetch_url_with_progress(url: str, show_progress: bool = False, chunk_size: int = 1024, timeout: int = 10) -&gt; str</code>","text":"<p>Fetch content from URL with streaming and optional progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch</p> required <code>show_progress</code> <code>bool</code> <p>Whether to display a progress bar during download</p> <code>False</code> <code>chunk_size</code> <code>int</code> <p>Size of chunks to read in bytes</p> <code>1024</code> <code>timeout</code> <code>int</code> <p>Request timeout in seconds</p> <code>10</code> <p>Returns:</p> Type Description <code>str</code> <p>Content as string</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If content cannot be fetched</p> Source code in <code>webdown/html_parser.py</code> <pre><code>def fetch_url_with_progress(\n    url: str, show_progress: bool = False, chunk_size: int = 1024, timeout: int = 10\n) -&gt; str:\n    \"\"\"Fetch content from URL with streaming and optional progress bar.\n\n    Args:\n        url: URL to fetch\n        show_progress: Whether to display a progress bar during download\n        chunk_size: Size of chunks to read in bytes\n        timeout: Request timeout in seconds\n\n    Returns:\n        Content as string\n\n    Raises:\n        WebdownError: If content cannot be fetched\n    \"\"\"\n    # Note: URL validation is now centralized in _get_normalized_config\n    # We assume URL is already validated when this function is called\n\n    try:\n        # Make a GET request with stream=True for both cases\n        response = requests.get(url, timeout=timeout, stream=True)\n        response.raise_for_status()\n\n        # Try to handle small responses without streaming for performance\n        small_response = _handle_small_response(response, show_progress)\n        if small_response is not None:\n            return small_response\n\n        # For larger responses or when progress is requested, use streaming\n        total_size = int(response.headers.get(\"content-length\", 0))\n        with _create_progress_bar(url, total_size, show_progress) as progress_bar:\n            return _process_response_chunks(response, progress_bar, chunk_size)\n\n    except (\n        requests.exceptions.Timeout,\n        requests.exceptions.ConnectionError,\n        requests.exceptions.HTTPError,\n        requests.exceptions.RequestException,\n    ) as e:\n        # This function raises a WebdownError with appropriate message\n        handle_request_exception(e, url)\n        # The line below is never reached but needed for type checking\n        raise RuntimeError(\"This should never be reached\")  # pragma: no cover\n</code></pre>"},{"location":"api/converter/#webdown.html_parser.extract_content_with_css","title":"<code>extract_content_with_css(html: str, css_selector: str) -&gt; str</code>","text":"<p>Extract specific content from HTML using a CSS selector.</p> <p>CSS selector is assumed to be already validated before this function is called.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>HTML content</p> required <code>css_selector</code> <code>str</code> <p>CSS selector to extract content (pre-validated)</p> required <p>Returns:</p> Type Description <code>str</code> <p>HTML content of selected elements</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If there is an error applying the selector</p> Source code in <code>webdown/html_parser.py</code> <pre><code>def extract_content_with_css(html: str, css_selector: str) -&gt; str:\n    \"\"\"Extract specific content from HTML using a CSS selector.\n\n    CSS selector is assumed to be already validated before this function is called.\n\n    Args:\n        html: HTML content\n        css_selector: CSS selector to extract content (pre-validated)\n\n    Returns:\n        HTML content of selected elements\n\n    Raises:\n        WebdownError: If there is an error applying the selector\n    \"\"\"\n    import warnings\n\n    # Note: No validation here - validation is now centralized in html_to_markdown\n\n    try:\n        soup = BeautifulSoup(html, \"html.parser\")\n        selected = soup.select(css_selector)\n        if selected:\n            return \"\".join(str(element) for element in selected)\n        else:\n            # Warning - no elements matched\n            warnings.warn(f\"CSS selector '{css_selector}' did not match any elements\")\n            return html\n    except Exception as e:\n        raise WebdownError(\n            f\"Error applying CSS selector '{css_selector}': {str(e)}\",\n            code=ErrorCode.CSS_SELECTOR_INVALID,\n        )\n</code></pre>"},{"location":"api/converter/#markdown-conversion","title":"Markdown Conversion","text":"<p>HTML to Markdown conversion functionality.</p> <p>This module handles conversion of HTML content to Markdown with optional features: - HTML to Markdown conversion using html2text - Table of contents generation - Content selection with CSS selectors - Compact output mode - Removal of invisible characters</p> <p>The main function is html_to_markdown(), but this module also provides helper functions for each conversion step.</p>"},{"location":"api/converter/#webdown.markdown_converter-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.markdown_converter.html_to_markdown","title":"<code>html_to_markdown(html: str, config: WebdownConfig) -&gt; str</code>","text":"<p>Convert HTML to Markdown with formatting options.</p> <p>This function takes HTML content and converts it to Markdown format based on the provided configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>HTML content to convert</p> required <code>config</code> <code>WebdownConfig</code> <p>Configuration options for the conversion</p> required <p>Returns:</p> Type Description <code>str</code> <p>Converted Markdown content</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; html = \"&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content with &lt;a href='#'&gt;link&lt;/a&gt;&lt;/p&gt;\"\n&gt;&gt;&gt; config = WebdownConfig()\n&gt;&gt;&gt; print(html_to_markdown(html, config))\n# Title\n</code></pre> <p>Content with link</p> <pre><code>&gt;&gt;&gt; config = WebdownConfig(include_links=False)\n&gt;&gt;&gt; print(html_to_markdown(html, config))\n# Title\n</code></pre> <p>Content with link</p> Source code in <code>webdown/markdown_converter.py</code> <pre><code>def html_to_markdown(\n    html: str,\n    config: WebdownConfig,\n) -&gt; str:\n    \"\"\"Convert HTML to Markdown with formatting options.\n\n    This function takes HTML content and converts it to Markdown format\n    based on the provided configuration object.\n\n    Args:\n        html: HTML content to convert\n        config: Configuration options for the conversion\n\n    Returns:\n        Converted Markdown content\n\n    Examples:\n        &gt;&gt;&gt; html = \"&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content with &lt;a href='#'&gt;link&lt;/a&gt;&lt;/p&gt;\"\n        &gt;&gt;&gt; config = WebdownConfig()\n        &gt;&gt;&gt; print(html_to_markdown(html, config))\n        # Title\n\n        Content with [link](#)\n\n        &gt;&gt;&gt; config = WebdownConfig(include_links=False)\n        &gt;&gt;&gt; print(html_to_markdown(html, config))\n        # Title\n\n        Content with link\n    \"\"\"\n    # Validate all configuration parameters\n    _validate_config(config)\n\n    # Extract specific content by CSS selector if provided\n    if config.css_selector:\n        html = extract_content_with_css(html, config.css_selector)\n\n    # Configure and run html2text\n    converter = _configure_html2text(config)\n    markdown = converter.handle(html)\n\n    # Clean up the markdown\n    markdown = clean_markdown(markdown, config.document_options.compact_output)\n\n    # Add table of contents if requested\n    if config.document_options.include_toc:\n        markdown = generate_table_of_contents(markdown)\n\n    return str(markdown)\n</code></pre>"},{"location":"api/converter/#xml-conversion","title":"XML Conversion","text":"<p>Markdown to Claude XML conversion functionality.</p> <p>This module handles conversion of Markdown content to Claude XML format: - Processes code blocks directly (no placeholders) - Handles headings, sections, and paragraphs - Generates metadata when requested - Creates a structured XML document for use with Claude</p> <p>The main function is markdown_to_claude_xml(), which converts Markdown content to a format suitable for Claude AI models.</p>"},{"location":"api/converter/#webdown.xml_converter-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.xml_converter.markdown_to_claude_xml","title":"<code>markdown_to_claude_xml(markdown: str, source_url: Optional[str] = None, include_metadata: bool = True) -&gt; str</code>","text":"<p>Convert Markdown content to Claude XML format.</p> <p>This function converts Markdown content to a structured XML format suitable for use with Claude AI models. It handles elements like headings, paragraphs, and code blocks, organizing them into a hierarchical XML document.</p> <p>Parameters:</p> Name Type Description Default <code>markdown</code> <code>str</code> <p>Markdown content to convert</p> required <code>source_url</code> <code>Optional[str]</code> <p>Source URL for the content (for metadata)</p> <code>None</code> <code>include_metadata</code> <code>bool</code> <p>Whether to include metadata section (title, source, date)</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Claude XML formatted content</p> Source code in <code>webdown/xml_converter.py</code> <pre><code>def markdown_to_claude_xml(\n    markdown: str,\n    source_url: Optional[str] = None,\n    include_metadata: bool = True,\n) -&gt; str:\n    \"\"\"Convert Markdown content to Claude XML format.\n\n    This function converts Markdown content to a structured XML format\n    suitable for use with Claude AI models. It handles elements like\n    headings, paragraphs, and code blocks, organizing them into a\n    hierarchical XML document.\n\n    Args:\n        markdown: Markdown content to convert\n        source_url: Source URL for the content (for metadata)\n        include_metadata: Whether to include metadata section (title, source, date)\n\n    Returns:\n        Claude XML formatted content\n    \"\"\"\n    xml_parts = []\n\n    # Use a fixed document tag - simplifying configuration\n    doc_tag = \"claude_documentation\"\n\n    # Root element\n    xml_parts.append(f\"&lt;{doc_tag}&gt;\")\n\n    # Extract title\n    title = extract_markdown_title(markdown)\n\n    # Add metadata if requested\n    if include_metadata:\n        xml_parts.extend(generate_metadata_xml(title, source_url))\n\n    # Begin content section\n    xml_parts.append(indent_xml(\"&lt;content&gt;\", 1))\n\n    # Process all content by section\n\n    # Extract all section headings\n    section_matches = list(re.finditer(r\"^(#+\\s+)(.+?)$\", markdown, re.MULTILINE))\n\n    if section_matches:\n        # Process each section including content following the heading\n        for i, match in enumerate(section_matches):\n            heading_start = match.start()\n            heading = match.group(0)\n            # If this is the last heading, content goes to the end\n            if i == len(section_matches) - 1:\n                content = markdown[heading_start + len(heading) :].strip()\n            else:\n                # Otherwise content goes until the next heading\n                next_heading_start = section_matches[i + 1].start()\n                content = markdown[\n                    heading_start + len(heading) : next_heading_start\n                ].strip()\n\n            # Create section with heading and content\n            section_xml = []\n            section_xml.append(indent_xml(\"&lt;section&gt;\", 2))\n            section_xml.append(\n                indent_xml(\n                    f\"&lt;heading&gt;{escape_xml(match.group(2).strip())}&lt;/heading&gt;\", 3\n                )\n            )\n\n            # Process content inside this section\n            if content:\n                section_xml.extend(_process_paragraphs(content, 3))\n\n            section_xml.append(indent_xml(\"&lt;/section&gt;\", 2))\n            xml_parts.extend(section_xml)\n\n        # Process content before the first heading (if any)\n        if section_matches[0].start() &gt; 0:\n            pre_content = markdown[: section_matches[0].start()].strip()\n            if pre_content:\n                # Add pre-heading content at the beginning\n                pre_parts = _process_paragraphs(pre_content, 2)\n\n                xml_parts = xml_parts[:2] + pre_parts + xml_parts[2:]\n    else:\n        # No headings - just process all content\n        xml_parts.extend(_process_paragraphs(markdown, 2))\n\n    # Close content and root\n    xml_parts.append(indent_xml(\"&lt;/content&gt;\", 1))\n    xml_parts.append(f\"&lt;/{doc_tag}&gt;\")\n\n    return \"\\n\".join(xml_parts)\n</code></pre>"},{"location":"api/converter/#webdown.xml_converter.process_section","title":"<code>process_section(match: Match[str], level: int) -&gt; List[str]</code>","text":"<p>Process a section (heading + content) into XML.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>Match[str]</code> <p>Regex match containing heading and content</p> required <code>level</code> <code>int</code> <p>Indentation level</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of XML strings for the section</p> Source code in <code>webdown/xml_converter.py</code> <pre><code>def process_section(match: Match[str], level: int) -&gt; List[str]:\n    \"\"\"Process a section (heading + content) into XML.\n\n    Args:\n        match: Regex match containing heading and content\n        level: Indentation level\n\n    Returns:\n        List of XML strings for the section\n    \"\"\"\n    heading_text = match.group(2).strip()\n    content = match.group(3).strip() if match.group(3) else \"\"\n\n    result = []\n\n    # Open section\n    result.append(indent_xml(\"&lt;section&gt;\", level))\n\n    # Add heading\n    result.append(\n        indent_xml(f\"&lt;heading&gt;{escape_xml(heading_text)}&lt;/heading&gt;\", level + 1)\n    )\n\n    # Process content\n    if content:\n        result.extend(_process_paragraphs(content, level + 1))\n\n    # Close section\n    result.append(indent_xml(\"&lt;/section&gt;\", level))\n\n    return result\n</code></pre>"},{"location":"api/converter/#crawler","title":"Crawler","text":"<p>Web crawler for converting multiple pages to Markdown or Claude XML.</p> <p>This module provides the core crawling functionality for webdown, allowing users to crawl multiple pages from a website and convert them to Markdown or Claude XML format.</p>"},{"location":"api/converter/#webdown.crawler-classes","title":"Classes","text":""},{"location":"api/converter/#webdown.crawler.CrawlerConfig","title":"<code>CrawlerConfig</code>  <code>dataclass</code>","text":"<p>Configuration for web crawling.</p> <p>Attributes:</p> Name Type Description <code>seed_urls</code> <code>list[str]</code> <p>List of URLs to start crawling from.</p> <code>output_dir</code> <code>str</code> <p>Directory to save converted files.</p> <code>max_depth</code> <code>int</code> <p>Maximum link depth from seed URLs (default: 3).</p> <code>delay_seconds</code> <code>float</code> <p>Delay between requests in seconds (default: 1.0).</p> <code>scope</code> <code>ScopeType</code> <p>Type of scope filtering to apply (default: SAME_SUBDOMAIN).</p> <code>path_prefix</code> <code>str | None</code> <p>Optional path prefix for PATH_PREFIX scope.</p> <code>conversion_config</code> <code>WebdownConfig</code> <p>Configuration for page conversion.</p> <code>verbose</code> <code>bool</code> <p>Whether to print progress messages.</p> <code>max_pages</code> <code>int</code> <p>Maximum number of pages to crawl (0 for unlimited).</p> Source code in <code>webdown/crawler.py</code> <pre><code>@dataclass\nclass CrawlerConfig:\n    \"\"\"Configuration for web crawling.\n\n    Attributes:\n        seed_urls: List of URLs to start crawling from.\n        output_dir: Directory to save converted files.\n        max_depth: Maximum link depth from seed URLs (default: 3).\n        delay_seconds: Delay between requests in seconds (default: 1.0).\n        scope: Type of scope filtering to apply (default: SAME_SUBDOMAIN).\n        path_prefix: Optional path prefix for PATH_PREFIX scope.\n        conversion_config: Configuration for page conversion.\n        verbose: Whether to print progress messages.\n        max_pages: Maximum number of pages to crawl (0 for unlimited).\n    \"\"\"\n\n    seed_urls: list[str]\n    output_dir: str\n    max_depth: int = 3\n    delay_seconds: float = 1.0\n    scope: ScopeType = ScopeType.SAME_SUBDOMAIN\n    path_prefix: str | None = None\n    conversion_config: WebdownConfig = field(default_factory=WebdownConfig)\n    verbose: bool = True\n    max_pages: int = 0\n</code></pre>"},{"location":"api/converter/#webdown.crawler-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.crawler.crawl","title":"<code>crawl(config: CrawlerConfig) -&gt; CrawlResult</code>","text":"<p>Execute a crawl operation starting from seed URLs.</p> <p>Uses breadth-first search to discover and convert pages within the configured scope. Respects rate limiting with configurable delays between requests.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CrawlerConfig</code> <p>Configuration for the crawl operation.</p> required <p>Returns:</p> Type Description <code>CrawlResult</code> <p>CrawlResult containing metadata for all crawled pages.</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If the output directory cannot be created or accessed.</p> Source code in <code>webdown/crawler.py</code> <pre><code>def crawl(config: CrawlerConfig) -&gt; CrawlResult:\n    \"\"\"Execute a crawl operation starting from seed URLs.\n\n    Uses breadth-first search to discover and convert pages within the\n    configured scope. Respects rate limiting with configurable delays\n    between requests.\n\n    Args:\n        config: Configuration for the crawl operation.\n\n    Returns:\n        CrawlResult containing metadata for all crawled pages.\n\n    Raises:\n        WebdownError: If the output directory cannot be created or accessed.\n    \"\"\"\n    result = CrawlResult(\n        start_time=datetime.now(),\n        seed_urls=config.seed_urls.copy(),\n        max_depth=config.max_depth,\n        output_format=config.conversion_config.format.name.lower(),\n    )\n\n    visited: set[str] = set()\n    queue: deque[tuple[str, int]] = deque()\n\n    for seed_url in config.seed_urls:\n        normalized = normalize_url(seed_url)\n        if normalized not in visited:\n            queue.append((seed_url, 0))\n            visited.add(normalized)\n\n    pages_crawled = 0\n\n    while queue:\n        if config.max_pages &gt; 0 and pages_crawled &gt;= config.max_pages:\n            if config.verbose:\n                print(f\"Reached maximum page limit ({config.max_pages})\")\n            break\n\n        url, depth = queue.popleft()\n\n        if depth &gt; config.max_depth:\n            continue\n\n        page = _crawl_single_page(url, depth, config, result)\n        result.pages.append(page)\n        pages_crawled += 1\n\n        if config.verbose:\n            status_char = \"+\" if page.status == \"success\" else \"!\"\n            print(f\"[{status_char}] {url}\")\n\n        if page.status == \"success\" and depth &lt; config.max_depth:\n            new_links = _discover_links(url, page, config, visited)\n            for link in new_links:\n                queue.append((link, depth + 1))\n\n        if queue and config.delay_seconds &gt; 0:\n            time.sleep(config.delay_seconds)\n\n    result.end_time = datetime.now()\n\n    manifest_path = write_manifest(result, config.output_dir)\n    if config.verbose:\n        print(f\"\\nCrawl complete: {result.successful_count} pages saved\")\n        print(f\"Manifest written to: {manifest_path}\")\n\n    return result\n</code></pre>"},{"location":"api/converter/#webdown.crawler.crawl_from_sitemap","title":"<code>crawl_from_sitemap(sitemap_url: str, config: CrawlerConfig) -&gt; CrawlResult</code>","text":"<p>Crawl pages listed in a sitemap.xml file.</p> <p>Instead of following links, this function parses a sitemap and converts all URLs listed in it.</p> <p>Parameters:</p> Name Type Description Default <code>sitemap_url</code> <code>str</code> <p>URL of the sitemap.xml file.</p> required <code>config</code> <code>CrawlerConfig</code> <p>Configuration for the crawl operation.</p> required <p>Returns:</p> Type Description <code>CrawlResult</code> <p>CrawlResult containing metadata for all crawled pages.</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If the sitemap cannot be fetched or parsed.</p> Source code in <code>webdown/crawler.py</code> <pre><code>def crawl_from_sitemap(\n    sitemap_url: str,\n    config: CrawlerConfig,\n) -&gt; CrawlResult:\n    \"\"\"Crawl pages listed in a sitemap.xml file.\n\n    Instead of following links, this function parses a sitemap and\n    converts all URLs listed in it.\n\n    Args:\n        sitemap_url: URL of the sitemap.xml file.\n        config: Configuration for the crawl operation.\n\n    Returns:\n        CrawlResult containing metadata for all crawled pages.\n\n    Raises:\n        WebdownError: If the sitemap cannot be fetched or parsed.\n    \"\"\"\n    result = CrawlResult(\n        start_time=datetime.now(),\n        seed_urls=[sitemap_url],\n        max_depth=0,\n        output_format=config.conversion_config.format.name.lower(),\n    )\n\n    if config.verbose:\n        print(f\"Parsing sitemap: {sitemap_url}\")\n\n    urls = parse_sitemap(sitemap_url)\n\n    if config.verbose:\n        print(f\"Found {len(urls)} URLs in sitemap\")\n\n    if config.scope != ScopeType.SAME_DOMAIN:\n        seed_url = config.seed_urls[0] if config.seed_urls else sitemap_url\n        urls = filter_links_by_scope(\n            urls,\n            seed_url,\n            config.scope,\n            config.path_prefix,\n        )\n        if config.verbose:\n            print(f\"After scope filtering: {len(urls)} URLs\")\n\n    pages_crawled = 0\n\n    for url in urls:\n        if config.max_pages &gt; 0 and pages_crawled &gt;= config.max_pages:\n            if config.verbose:\n                print(f\"Reached maximum page limit ({config.max_pages})\")\n            break\n\n        page = _crawl_single_page(url, 0, config, result)\n        result.pages.append(page)\n        pages_crawled += 1\n\n        if config.verbose:\n            status_char = \"+\" if page.status == \"success\" else \"!\"\n            print(f\"[{status_char}] {url}\")\n\n        if pages_crawled &lt; len(urls) and config.delay_seconds &gt; 0:\n            time.sleep(config.delay_seconds)\n\n    result.end_time = datetime.now()\n\n    manifest_path = write_manifest(result, config.output_dir)\n    if config.verbose:\n        print(f\"\\nCrawl complete: {result.successful_count} pages saved\")\n        print(f\"Manifest written to: {manifest_path}\")\n\n    return result\n</code></pre>"},{"location":"api/converter/#link-extraction","title":"Link Extraction","text":"<p>Link extraction and URL handling utilities for the crawler.</p> <p>This module provides functions for extracting links from HTML content, normalizing URLs for deduplication, filtering links by scope, and parsing sitemap.xml files.</p>"},{"location":"api/converter/#webdown.link_extractor-classes","title":"Classes","text":""},{"location":"api/converter/#webdown.link_extractor.ScopeType","title":"<code>ScopeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of crawl scope types.</p> Source code in <code>webdown/link_extractor.py</code> <pre><code>class ScopeType(Enum):\n    \"\"\"Enumeration of crawl scope types.\"\"\"\n\n    SAME_DOMAIN = auto()\n    SAME_SUBDOMAIN = auto()\n    PATH_PREFIX = auto()\n</code></pre>"},{"location":"api/converter/#webdown.link_extractor-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.link_extractor.extract_links","title":"<code>extract_links(html: str, base_url: str) -&gt; list[str]</code>","text":"<p>Extract and resolve all links from HTML content.</p> <p>Finds all  links in the HTML and resolves them to absolute URLs using the base URL. <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML content to extract links from.</p> required <code>base_url</code> <code>str</code> <p>The base URL for resolving relative links.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of absolute URLs found in the HTML.</p> Source code in <code>webdown/link_extractor.py</code> <pre><code>def extract_links(html: str, base_url: str) -&gt; list[str]:\n    \"\"\"Extract and resolve all links from HTML content.\n\n    Finds all &lt;a href=\"...\"&gt; links in the HTML and resolves them\n    to absolute URLs using the base URL.\n\n    Args:\n        html: The HTML content to extract links from.\n        base_url: The base URL for resolving relative links.\n\n    Returns:\n        A list of absolute URLs found in the HTML.\n    \"\"\"\n    soup = BeautifulSoup(html, \"html.parser\")\n    links: list[str] = []\n\n    for anchor in soup.find_all(\"a\", href=True):\n        href = anchor.get(\"href\", \"\")\n        if not isinstance(href, str):\n            continue\n        if not href or href.startswith((\"#\", \"javascript:\", \"mailto:\", \"tel:\")):\n            continue\n\n        absolute_url = urljoin(base_url, href)\n        parsed = urlparse(absolute_url)\n\n        if parsed.scheme in (\"http\", \"https\"):\n            links.append(absolute_url)\n\n    return links\n</code></pre>"},{"location":"api/converter/#webdown.link_extractor.normalize_url","title":"<code>normalize_url(url: str) -&gt; str</code>","text":"<p>Normalize a URL for deduplication.</p> <p>Normalization includes: - Lowercasing the scheme and domain - Removing fragments (#anchor) - Removing trailing slashes (except for root paths) - Sorting and keeping query parameters</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to normalize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The normalized URL string.</p> Source code in <code>webdown/link_extractor.py</code> <pre><code>def normalize_url(url: str) -&gt; str:\n    \"\"\"Normalize a URL for deduplication.\n\n    Normalization includes:\n    - Lowercasing the scheme and domain\n    - Removing fragments (#anchor)\n    - Removing trailing slashes (except for root paths)\n    - Sorting and keeping query parameters\n\n    Args:\n        url: The URL to normalize.\n\n    Returns:\n        The normalized URL string.\n    \"\"\"\n    parsed = urlparse(url)\n\n    scheme = parsed.scheme.lower()\n    netloc = parsed.netloc.lower()\n    path = parsed.path\n\n    if path != \"/\" and path.endswith(\"/\"):\n        path = path.rstrip(\"/\")\n\n    if not path:\n        path = \"/\"\n\n    normalized = urlunparse((scheme, netloc, path, parsed.params, parsed.query, \"\"))\n\n    return normalized\n</code></pre>"},{"location":"api/converter/#webdown.link_extractor.filter_links_by_scope","title":"<code>filter_links_by_scope(links: list[str], seed_url: str, scope: ScopeType, path_prefix: str | None = None) -&gt; list[str]</code>","text":"<p>Filter links to only those within the configured scope.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list[str]</code> <p>List of URLs to filter.</p> required <code>seed_url</code> <code>str</code> <p>The original seed URL used to determine scope.</p> required <code>scope</code> <code>ScopeType</code> <p>The type of scope filtering to apply.</p> required <code>path_prefix</code> <code>str | None</code> <p>Optional path prefix for PATH_PREFIX scope.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Filtered list of URLs that match the scope criteria.</p> Source code in <code>webdown/link_extractor.py</code> <pre><code>def filter_links_by_scope(\n    links: list[str],\n    seed_url: str,\n    scope: ScopeType,\n    path_prefix: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Filter links to only those within the configured scope.\n\n    Args:\n        links: List of URLs to filter.\n        seed_url: The original seed URL used to determine scope.\n        scope: The type of scope filtering to apply.\n        path_prefix: Optional path prefix for PATH_PREFIX scope.\n\n    Returns:\n        Filtered list of URLs that match the scope criteria.\n    \"\"\"\n    seed_parsed = urlparse(seed_url)\n    filtered: list[str] = []\n\n    for link in links:\n        link_parsed = urlparse(link)\n\n        if scope == ScopeType.SAME_DOMAIN:\n            seed_domain = _get_base_domain(seed_parsed.netloc)\n            link_domain = _get_base_domain(link_parsed.netloc)\n            if seed_domain == link_domain:\n                filtered.append(link)\n\n        elif scope == ScopeType.SAME_SUBDOMAIN:\n            if seed_parsed.netloc.lower() == link_parsed.netloc.lower():\n                filtered.append(link)\n\n        elif scope == ScopeType.PATH_PREFIX:\n            if seed_parsed.netloc.lower() != link_parsed.netloc.lower():\n                continue\n\n            prefix = path_prefix if path_prefix else seed_parsed.path\n            if not prefix.endswith(\"/\"):\n                prefix = prefix.rsplit(\"/\", 1)[0] + \"/\"\n\n            if link_parsed.path.startswith(prefix) or link_parsed.path == prefix.rstrip(\n                \"/\"\n            ):\n                filtered.append(link)\n\n    return filtered\n</code></pre>"},{"location":"api/converter/#webdown.link_extractor.parse_sitemap","title":"<code>parse_sitemap(sitemap_url: str, timeout: int = 30) -&gt; list[str]</code>","text":"<p>Parse a sitemap.xml file and return the list of URLs.</p> <p>Supports standard sitemap.xml format with  elements. Also handles sitemap index files that reference other sitemaps. <p>Parameters:</p> Name Type Description Default <code>sitemap_url</code> <code>str</code> <p>URL of the sitemap.xml file.</p> required <code>timeout</code> <code>int</code> <p>Request timeout in seconds.</p> <code>30</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of URLs found in the sitemap.</p> <p>Raises:</p> Type Description <code>WebdownError</code> <p>If the sitemap cannot be fetched or parsed.</p> Source code in <code>webdown/link_extractor.py</code> <pre><code>def parse_sitemap(sitemap_url: str, timeout: int = 30) -&gt; list[str]:\n    \"\"\"Parse a sitemap.xml file and return the list of URLs.\n\n    Supports standard sitemap.xml format with &lt;url&gt;&lt;loc&gt; elements.\n    Also handles sitemap index files that reference other sitemaps.\n\n    Args:\n        sitemap_url: URL of the sitemap.xml file.\n        timeout: Request timeout in seconds.\n\n    Returns:\n        List of URLs found in the sitemap.\n\n    Raises:\n        WebdownError: If the sitemap cannot be fetched or parsed.\n    \"\"\"\n    try:\n        response = requests.get(sitemap_url, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise WebdownError(\n            f\"Failed to fetch sitemap: {e}\",\n            ErrorCode.SITEMAP_PARSE_ERROR,\n        ) from e\n\n    try:\n        root = ET.fromstring(response.content)\n    except ET.ParseError as e:\n        raise WebdownError(\n            f\"Failed to parse sitemap XML: {e}\",\n            ErrorCode.SITEMAP_PARSE_ERROR,\n        ) from e\n\n    ns = {\"sm\": \"http://www.sitemaps.org/schemas/sitemap/0.9\"}\n    urls: list[str] = []\n\n    sitemap_refs = root.findall(\".//sm:sitemap/sm:loc\", ns)\n    if sitemap_refs:\n        for sitemap_ref in sitemap_refs:\n            if sitemap_ref.text:\n                child_urls = parse_sitemap(sitemap_ref.text, timeout)\n                urls.extend(child_urls)\n    else:\n        for loc in root.findall(\".//sm:url/sm:loc\", ns):\n            if loc.text:\n                urls.append(loc.text.strip())\n\n        if not urls:\n            for loc in root.findall(\".//url/loc\"):\n                if loc.text:\n                    urls.append(loc.text.strip())\n            for loc in root.findall(\".//loc\"):\n                if loc.text and loc.text.strip().startswith(\"http\"):\n                    urls.append(loc.text.strip())\n\n    return urls\n</code></pre>"},{"location":"api/converter/#output-management","title":"Output Management","text":"<p>Output file management for the crawler.</p> <p>This module handles converting URLs to file paths, managing the output directory structure, and writing the crawl manifest (index.json).</p>"},{"location":"api/converter/#webdown.output_manager-classes","title":"Classes","text":""},{"location":"api/converter/#webdown.output_manager.CrawlResult","title":"<code>CrawlResult</code>  <code>dataclass</code>","text":"<p>Result of a crawl operation.</p> <p>Attributes:</p> Name Type Description <code>pages</code> <code>list[CrawledPage]</code> <p>List of all crawled pages with their metadata.</p> <code>start_time</code> <code>datetime</code> <p>When the crawl started.</p> <code>end_time</code> <code>datetime</code> <p>When the crawl completed.</p> <code>seed_urls</code> <code>list[str]</code> <p>The original seed URLs used to start the crawl.</p> <code>max_depth</code> <code>int</code> <p>The maximum depth setting used.</p> <code>output_format</code> <code>str</code> <p>The output format used (markdown or claude_xml).</p> Source code in <code>webdown/output_manager.py</code> <pre><code>@dataclass\nclass CrawlResult:\n    \"\"\"Result of a crawl operation.\n\n    Attributes:\n        pages: List of all crawled pages with their metadata.\n        start_time: When the crawl started.\n        end_time: When the crawl completed.\n        seed_urls: The original seed URLs used to start the crawl.\n        max_depth: The maximum depth setting used.\n        output_format: The output format used (markdown or claude_xml).\n    \"\"\"\n\n    pages: list[CrawledPage] = field(default_factory=list)\n    start_time: datetime = field(default_factory=datetime.now)\n    end_time: datetime = field(default_factory=datetime.now)\n    seed_urls: list[str] = field(default_factory=list)\n    max_depth: int = 3\n    output_format: str = \"markdown\"\n\n    @property\n    def successful_count(self) -&gt; int:\n        \"\"\"Return the number of successfully crawled pages.\"\"\"\n        return sum(1 for p in self.pages if p.status == \"success\")\n\n    @property\n    def error_count(self) -&gt; int:\n        \"\"\"Return the number of pages that failed to crawl.\"\"\"\n        return sum(1 for p in self.pages if p.status == \"error\")\n\n    @property\n    def skipped_count(self) -&gt; int:\n        \"\"\"Return the number of skipped pages.\"\"\"\n        return sum(1 for p in self.pages if p.status == \"skipped\")\n</code></pre>"},{"location":"api/converter/#webdown.output_manager.CrawlResult-attributes","title":"Attributes","text":""},{"location":"api/converter/#webdown.output_manager.CrawlResult.error_count","title":"<code>error_count: int</code>  <code>property</code>","text":"<p>Return the number of pages that failed to crawl.</p>"},{"location":"api/converter/#webdown.output_manager.CrawlResult.skipped_count","title":"<code>skipped_count: int</code>  <code>property</code>","text":"<p>Return the number of skipped pages.</p>"},{"location":"api/converter/#webdown.output_manager.CrawlResult.successful_count","title":"<code>successful_count: int</code>  <code>property</code>","text":"<p>Return the number of successfully crawled pages.</p>"},{"location":"api/converter/#webdown.output_manager.CrawledPage","title":"<code>CrawledPage</code>  <code>dataclass</code>","text":"<p>Metadata for a crawled page.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The original URL that was crawled.</p> <code>output_path</code> <code>str</code> <p>Relative path to the output file from the output directory.</p> <code>title</code> <code>str | None</code> <p>The page title extracted from the content, if available.</p> <code>crawled_at</code> <code>datetime</code> <p>Timestamp when the page was crawled.</p> <code>depth</code> <code>int</code> <p>The crawl depth from the seed URL (0 for seed URLs).</p> <code>status</code> <code>str</code> <p>The crawl status (\"success\", \"error\", or \"skipped\").</p> <code>error_message</code> <code>str | None</code> <p>Error message if status is \"error\", None otherwise.</p> Source code in <code>webdown/output_manager.py</code> <pre><code>@dataclass\nclass CrawledPage:\n    \"\"\"Metadata for a crawled page.\n\n    Attributes:\n        url: The original URL that was crawled.\n        output_path: Relative path to the output file from the output directory.\n        title: The page title extracted from the content, if available.\n        crawled_at: Timestamp when the page was crawled.\n        depth: The crawl depth from the seed URL (0 for seed URLs).\n        status: The crawl status (\"success\", \"error\", or \"skipped\").\n        error_message: Error message if status is \"error\", None otherwise.\n    \"\"\"\n\n    url: str\n    output_path: str\n    title: str | None\n    crawled_at: datetime\n    depth: int\n    status: str\n    error_message: str | None = None\n</code></pre>"},{"location":"api/converter/#webdown.output_manager-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.output_manager.url_to_filepath","title":"<code>url_to_filepath(url: str, output_dir: str, output_format: OutputFormat = OutputFormat.MARKDOWN) -&gt; str</code>","text":"<p>Convert a URL to an output file path.</p> <p>Creates a path structure that mirrors the URL structure: - https://example.com/docs/page -&gt; output_dir/example.com/docs/page.md - https://example.com/docs/ -&gt; output_dir/example.com/docs/index.md - https://example.com/ -&gt; output_dir/example.com/index.md</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to convert to a file path.</p> required <code>output_dir</code> <code>str</code> <p>The base output directory.</p> required <code>output_format</code> <code>OutputFormat</code> <p>The output format (determines file extension).</p> <code>MARKDOWN</code> <p>Returns:</p> Type Description <code>str</code> <p>The full file path for the converted content.</p> Source code in <code>webdown/output_manager.py</code> <pre><code>def url_to_filepath(\n    url: str,\n    output_dir: str,\n    output_format: OutputFormat = OutputFormat.MARKDOWN,\n) -&gt; str:\n    \"\"\"Convert a URL to an output file path.\n\n    Creates a path structure that mirrors the URL structure:\n    - https://example.com/docs/page -&gt; output_dir/example.com/docs/page.md\n    - https://example.com/docs/ -&gt; output_dir/example.com/docs/index.md\n    - https://example.com/ -&gt; output_dir/example.com/index.md\n\n    Args:\n        url: The URL to convert to a file path.\n        output_dir: The base output directory.\n        output_format: The output format (determines file extension).\n\n    Returns:\n        The full file path for the converted content.\n    \"\"\"\n    parsed = urlparse(url)\n    domain = parsed.netloc.lower()\n\n    if \":\" in domain:\n        domain = domain.replace(\":\", \"_\")\n\n    path = parsed.path\n    if not path or path == \"/\":\n        path = \"/index\"\n    elif path.endswith(\"/\"):\n        path = path + \"index\"\n\n    path = path.lstrip(\"/\")\n\n    if path.endswith(\".html\") or path.endswith(\".htm\"):\n        path = re.sub(r\"\\.html?$\", \"\", path)\n\n    path = _sanitize_path(path)\n\n    extension = \".xml\" if output_format == OutputFormat.CLAUDE_XML else \".md\"\n\n    full_path = os.path.join(output_dir, domain, path + extension)\n\n    return full_path\n</code></pre>"},{"location":"api/converter/#webdown.output_manager.write_manifest","title":"<code>write_manifest(result: CrawlResult, output_dir: str) -&gt; str</code>","text":"<p>Write the crawl manifest (index.json) to the output directory.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>CrawlResult</code> <p>The crawl result containing all page metadata.</p> required <code>output_dir</code> <code>str</code> <p>The output directory to write the manifest to.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the written manifest file.</p> Source code in <code>webdown/output_manager.py</code> <pre><code>def write_manifest(result: CrawlResult, output_dir: str) -&gt; str:\n    \"\"\"Write the crawl manifest (index.json) to the output directory.\n\n    Args:\n        result: The crawl result containing all page metadata.\n        output_dir: The output directory to write the manifest to.\n\n    Returns:\n        The path to the written manifest file.\n    \"\"\"\n    manifest = {\n        \"version\": \"1.0\",\n        \"crawl_info\": {\n            \"seed_urls\": result.seed_urls,\n            \"start_time\": result.start_time.isoformat(),\n            \"end_time\": result.end_time.isoformat(),\n            \"total_pages\": len(result.pages),\n            \"successful\": result.successful_count,\n            \"errors\": result.error_count,\n            \"skipped\": result.skipped_count,\n            \"max_depth\": result.max_depth,\n            \"output_format\": result.output_format,\n        },\n        \"pages\": [_page_to_dict(page) for page in result.pages],\n    }\n\n    manifest_path = os.path.join(output_dir, \"index.json\")\n    ensure_output_directory(manifest_path)\n\n    with open(manifest_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(manifest, f, indent=2, ensure_ascii=False)\n\n    return manifest_path\n</code></pre>"},{"location":"api/converter/#error-handling","title":"Error Handling","text":"<p>Error handling utilities for webdown.</p> <p>This module provides centralized error handling utilities used throughout the webdown package.</p>"},{"location":"api/converter/#webdown.error_utils-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.error_utils.handle_validation_error","title":"<code>handle_validation_error(message: str, code: str = ErrorCode.VALIDATION_ERROR) -&gt; NoReturn</code>","text":"<p>Handle a validation error and raise a WebdownError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>code</code> <code>str</code> <p>Error code</p> <code>VALIDATION_ERROR</code> <p>Raises:</p> Type Description <code>WebdownError</code> <p>Always raised with appropriate message</p> Source code in <code>webdown/error_utils.py</code> <pre><code>def handle_validation_error(\n    message: str, code: str = ErrorCode.VALIDATION_ERROR\n) -&gt; NoReturn:\n    \"\"\"Handle a validation error and raise a WebdownError.\n\n    Args:\n        message: Error message\n        code: Error code\n\n    Raises:\n        WebdownError: Always raised with appropriate message\n    \"\"\"\n    raise WebdownError(message, code=code)\n</code></pre>"},{"location":"api/converter/#webdown.error_utils.get_friendly_error_message","title":"<code>get_friendly_error_message(error: Exception) -&gt; str</code>","text":"<p>Get a user-friendly error message for an exception.</p> <p>This function is intended for CLI and user-facing interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The exception to get a message for</p> required <p>Returns:</p> Type Description <code>str</code> <p>A user-friendly error message</p> Source code in <code>webdown/error_utils.py</code> <pre><code>def get_friendly_error_message(error: Exception) -&gt; str:\n    \"\"\"Get a user-friendly error message for an exception.\n\n    This function is intended for CLI and user-facing interfaces.\n\n    Args:\n        error: The exception to get a message for\n\n    Returns:\n        A user-friendly error message\n    \"\"\"\n    # For WebdownError, we already have a good message\n    if isinstance(error, WebdownError):\n        # Handle URL validation errors specially for better UX\n        message = str(error)\n        if hasattr(error, \"code\") and error.code == ErrorCode.URL_INVALID:\n            message += (\n                \"\\nPlease make sure the URL includes a valid protocol \"\n                \"and domain (like https://example.com).\"\n            )\n        return message\n\n    # For other exceptions, provide a generic message\n    return f\"An unexpected error occurred: {str(error)}\"\n</code></pre>"},{"location":"api/converter/#webdown.error_utils.format_error_for_cli","title":"<code>format_error_for_cli(error: Exception) -&gt; str</code>","text":"<p>Format an error message for CLI output.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The exception to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted error message for CLI output</p> Source code in <code>webdown/error_utils.py</code> <pre><code>def format_error_for_cli(error: Exception) -&gt; str:\n    \"\"\"Format an error message for CLI output.\n\n    Args:\n        error: The exception to format\n\n    Returns:\n        A formatted error message for CLI output\n    \"\"\"\n    friendly_message = get_friendly_error_message(error)\n\n    # For CLI, prefix with \"Error: \" and format nicely\n    lines = friendly_message.split(\"\\n\")\n    if len(lines) == 1:\n        return f\"Error: {friendly_message}\"\n\n    # For multi-line messages, format with indentation\n    result = [\"Error:\"]\n    for line in lines:\n        result.append(f\"  {line}\")\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"api/converter/#webdown.error_utils.handle_request_exception","title":"<code>handle_request_exception(exception: Exception, url: str) -&gt; NoReturn</code>","text":"<p>Handle a request exception and raise a WebdownError with appropriate message.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception to handle</p> required <code>url</code> <code>str</code> <p>The URL that was requested</p> required <p>Raises:</p> Type Description <code>WebdownError</code> <p>Always raised with appropriate message</p> Source code in <code>webdown/error_utils.py</code> <pre><code>def handle_request_exception(exception: Exception, url: str) -&gt; NoReturn:\n    \"\"\"Handle a request exception and raise a WebdownError with appropriate message.\n\n    Args:\n        exception: The exception to handle\n        url: The URL that was requested\n\n    Raises:\n        WebdownError: Always raised with appropriate message\n    \"\"\"\n    if isinstance(exception, requests.exceptions.Timeout):\n        raise WebdownError(\n            f\"Timeout error fetching {url}. The server took too long to respond.\",\n            code=ErrorCode.NETWORK_TIMEOUT,\n        )\n    elif isinstance(exception, requests.exceptions.ConnectionError):\n        raise WebdownError(\n            f\"Connection error fetching {url}. Please check your internet connection.\",\n            code=ErrorCode.NETWORK_CONNECTION,\n        )\n    elif isinstance(exception, requests.exceptions.HTTPError):\n        # Extract status code if available\n        status_code = None\n        if hasattr(exception, \"response\") and hasattr(\n            exception.response, \"status_code\"\n        ):\n            status_code = exception.response.status_code\n\n        status_msg = f\" (Status code: {status_code})\" if status_code else \"\"\n        raise WebdownError(\n            f\"HTTP error fetching {url}{status_msg}. The server returned an error.\",\n            code=ErrorCode.HTTP_ERROR,\n        )\n    else:\n        # Generic RequestException or any other exception\n        raise WebdownError(\n            f\"Error fetching {url}: {str(exception)}\",\n            code=ErrorCode.REQUEST_ERROR,\n        )\n</code></pre>"},{"location":"api/converter/#exceptions","title":"Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for webdown errors.</p> <p>This exception class is used for all errors raised by the webdown package. The error type is indicated by a descriptive message and an error code, allowing programmatic error handling.</p> Error types include <p>URL format errors: When the URL doesn't follow standard format Network errors: Connection issues, timeouts, HTTP errors Parsing errors: Issues with processing the HTML content Validation errors: Invalid parameters or configuration</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str</code> <p>Error code for programmatic error handling</p> Source code in <code>webdown/config.py</code> <pre><code>class WebdownError(Exception):\n    \"\"\"Exception for webdown errors.\n\n    This exception class is used for all errors raised by the webdown package.\n    The error type is indicated by a descriptive message and an error code,\n    allowing programmatic error handling.\n\n    Error types include:\n        URL format errors: When the URL doesn't follow standard format\n        Network errors: Connection issues, timeouts, HTTP errors\n        Parsing errors: Issues with processing the HTML content\n        Validation errors: Invalid parameters or configuration\n\n    Attributes:\n        code (str): Error code for programmatic error handling\n    \"\"\"\n\n    def __init__(self, message: str, code: str = \"UNEXPECTED_ERROR\"):\n        \"\"\"Initialize a WebdownError.\n\n        Args:\n            message: Error message\n            code: Error code for programmatic error handling\n        \"\"\"\n        super().__init__(message)\n        self.code = code\n</code></pre>"},{"location":"api/converter/#webdown.converter.WebdownError-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.converter.WebdownError.__init__","title":"<code>__init__(message: str, code: str = 'UNEXPECTED_ERROR')</code>","text":"<p>Initialize a WebdownError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>code</code> <code>str</code> <p>Error code for programmatic error handling</p> <code>'UNEXPECTED_ERROR'</code> Source code in <code>webdown/config.py</code> <pre><code>def __init__(self, message: str, code: str = \"UNEXPECTED_ERROR\"):\n    \"\"\"Initialize a WebdownError.\n\n    Args:\n        message: Error message\n        code: Error code for programmatic error handling\n    \"\"\"\n    super().__init__(message)\n    self.code = code\n</code></pre>"},{"location":"api/converter/#validation","title":"Validation","text":"<p>Validation utilities for webdown.</p> <p>This module provides centralized validation functions for various inputs used throughout the webdown package.</p>"},{"location":"api/converter/#webdown.validation-functions","title":"Functions","text":""},{"location":"api/converter/#webdown.validation.validate_url","title":"<code>validate_url(url: str) -&gt; str</code>","text":"<p>Validate a URL and return it if valid.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated URL</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_url(url: str) -&gt; str:\n    \"\"\"Validate a URL and return it if valid.\n\n    Args:\n        url: The URL to validate\n\n    Returns:\n        The validated URL\n\n    Raises:\n        ValueError: If the URL is invalid\n    \"\"\"\n    if not url:\n        raise ValueError(\"URL cannot be empty\")\n\n    parsed = urllib.parse.urlparse(url)\n\n    # Check if URL has a scheme and netloc\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(\n            f\"Invalid URL: {url}. URL must include scheme \"\n            f\"(http:// or https://) and domain.\"\n        )\n\n    # Ensure scheme is http or https\n    if parsed.scheme not in [\"http\", \"https\"]:\n        raise ValueError(\n            f\"Invalid URL scheme: {parsed.scheme}. Only http and https are supported.\"\n        )\n\n    return url\n</code></pre>"},{"location":"api/converter/#webdown.validation.validate_css_selector","title":"<code>validate_css_selector(selector: str) -&gt; str</code>","text":"<p>Validate a CSS selector.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>The CSS selector to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated CSS selector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the selector is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_css_selector(selector: str) -&gt; str:\n    \"\"\"Validate a CSS selector.\n\n    Args:\n        selector: The CSS selector to validate\n\n    Returns:\n        The validated CSS selector\n\n    Raises:\n        ValueError: If the selector is invalid\n    \"\"\"\n    if not selector:\n        raise ValueError(\"CSS selector cannot be empty\")\n\n    # Simple validation - just create a soup and try using the selector\n    # This will raise a ValueError if the selector is invalid\n    try:\n        soup = BeautifulSoup(\"&lt;html&gt;&lt;/html&gt;\", \"html.parser\")\n        soup.select(selector)\n        return selector\n    except Exception as e:\n        raise ValueError(f\"Invalid CSS selector: {selector}. Error: {str(e)}\")\n</code></pre>"},{"location":"api/converter/#webdown.validation.validate_body_width","title":"<code>validate_body_width(width: Optional[int]) -&gt; Optional[int]</code>","text":"<p>Validate body width parameter.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>Optional[int]</code> <p>The body width to validate, or None for no width limit</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The validated body width or None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the width is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_body_width(width: Optional[int]) -&gt; Optional[int]:\n    \"\"\"Validate body width parameter.\n\n    Args:\n        width: The body width to validate, or None for no width limit\n\n    Returns:\n        The validated body width or None\n\n    Raises:\n        ValueError: If the width is invalid\n    \"\"\"\n    if width is None:\n        return None\n\n    # Ensure width is an integer and within reasonable range\n    if not isinstance(width, int):\n        raise ValueError(f\"Body width must be an integer, got {type(width).__name__}\")\n\n    if width &lt; 0:\n        raise ValueError(f\"Body width cannot be negative, got {width}\")\n\n    # Upper limit of 2000 is arbitrary but reasonable\n    if width &gt; 2000:\n        raise ValueError(f\"Body width too large, maximum is 2000, got {width}\")\n\n    return width\n</code></pre>"},{"location":"api/converter/#webdown.validation.validate_numeric_parameter","title":"<code>validate_numeric_parameter(name: str, value: Optional[int], min_value: Optional[int] = None, max_value: Optional[int] = None) -&gt; Optional[int]</code>","text":"<p>Validate a numeric parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter (for error messages)</p> required <code>value</code> <code>Optional[int]</code> <p>The value to validate</p> required <code>min_value</code> <code>Optional[int]</code> <p>Optional minimum value</p> <code>None</code> <code>max_value</code> <code>Optional[int]</code> <p>Optional maximum value</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_numeric_parameter(\n    name: str,\n    value: Optional[int],\n    min_value: Optional[int] = None,\n    max_value: Optional[int] = None,\n) -&gt; Optional[int]:\n    \"\"\"Validate a numeric parameter.\n\n    Args:\n        name: The name of the parameter (for error messages)\n        value: The value to validate\n        min_value: Optional minimum value\n        max_value: Optional maximum value\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If the value is invalid\n    \"\"\"\n    if value is None:\n        return None\n\n    if not isinstance(value, int):\n        raise ValueError(f\"{name} must be an integer, got {type(value).__name__}\")\n\n    if min_value is not None and value &lt; min_value:\n        raise ValueError(f\"{name} must be at least {min_value}, got {value}\")\n\n    if max_value is not None and value &gt; max_value:\n        raise ValueError(f\"{name} must be at most {max_value}, got {value}\")\n\n    return value\n</code></pre>"},{"location":"api/converter/#webdown.validation.validate_string_parameter","title":"<code>validate_string_parameter(name: str, value: Optional[str], allowed_values: Optional[list] = None) -&gt; Optional[str]</code>","text":"<p>Validate a string parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter (for error messages)</p> required <code>value</code> <code>Optional[str]</code> <p>The value to validate</p> required <code>allowed_values</code> <code>Optional[list]</code> <p>Optional list of allowed values</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_string_parameter(\n    name: str, value: Optional[str], allowed_values: Optional[list] = None\n) -&gt; Optional[str]:\n    \"\"\"Validate a string parameter.\n\n    Args:\n        name: The name of the parameter (for error messages)\n        value: The value to validate\n        allowed_values: Optional list of allowed values\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If the value is invalid\n    \"\"\"\n    if value is None:\n        return None\n\n    if not isinstance(value, str):\n        raise ValueError(f\"{name} must be a string, got {type(value).__name__}\")\n\n    if allowed_values is not None and value not in allowed_values:\n        allowed_str = \", \".join(allowed_values)\n        raise ValueError(f\"{name} must be one of: {allowed_str}, got {value}\")\n\n    return value\n</code></pre>"},{"location":"api/converter/#webdown.validation.validate_boolean_parameter","title":"<code>validate_boolean_parameter(name: str, value: Optional[bool]) -&gt; Optional[bool]</code>","text":"<p>Validate a boolean parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter (for error messages)</p> required <code>value</code> <code>Optional[bool]</code> <p>The value to validate</p> required <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is invalid</p> Source code in <code>webdown/validation.py</code> <pre><code>def validate_boolean_parameter(name: str, value: Optional[bool]) -&gt; Optional[bool]:\n    \"\"\"Validate a boolean parameter.\n\n    Args:\n        name: The name of the parameter (for error messages)\n        value: The value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If the value is invalid\n    \"\"\"\n    if value is None:\n        return None\n\n    if not isinstance(value, bool):\n        raise ValueError(f\"{name} must be a boolean, got {type(value).__name__}\")\n\n    return value\n</code></pre>"}]}